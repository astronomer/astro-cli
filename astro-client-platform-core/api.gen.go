// Package astroplatformcore provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package astroplatformcore

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

const (
	JWTScopes = "JWT.Scopes"
)

// Defines values for BasicSubjectProfileSubjectType.
const (
	SERVICEKEY BasicSubjectProfileSubjectType = "SERVICEKEY"
	USER       BasicSubjectProfileSubjectType = "USER"
)

// Defines values for ClusterCloudProvider.
const (
	ClusterCloudProviderAWS   ClusterCloudProvider = "AWS"
	ClusterCloudProviderAZURE ClusterCloudProvider = "AZURE"
	ClusterCloudProviderGCP   ClusterCloudProvider = "GCP"
)

// Defines values for ClusterStatus.
const (
	ClusterStatusCREATED      ClusterStatus = "CREATED"
	ClusterStatusCREATEFAILED ClusterStatus = "CREATE_FAILED"
	ClusterStatusCREATING     ClusterStatus = "CREATING"
	ClusterStatusUPDATEFAILED ClusterStatus = "UPDATE_FAILED"
	ClusterStatusUPDATING     ClusterStatus = "UPDATING"
)

// Defines values for ClusterType.
const (
	ClusterTypeDEDICATED ClusterType = "DEDICATED"
	ClusterTypeHYBRID    ClusterType = "HYBRID"
)

// Defines values for ClusterOptionsProvider.
const (
	ClusterOptionsProviderAWS   ClusterOptionsProvider = "AWS"
	ClusterOptionsProviderAZURE ClusterOptionsProvider = "AZURE"
	ClusterOptionsProviderGCP   ClusterOptionsProvider = "GCP"
)

// Defines values for CreateAwsClusterRequestCloudProvider.
const (
	CreateAwsClusterRequestCloudProviderAWS   CreateAwsClusterRequestCloudProvider = "AWS"
	CreateAwsClusterRequestCloudProviderAZURE CreateAwsClusterRequestCloudProvider = "AZURE"
	CreateAwsClusterRequestCloudProviderGCP   CreateAwsClusterRequestCloudProvider = "GCP"
)

// Defines values for CreateAwsClusterRequestType.
const (
	CreateAwsClusterRequestTypeDEDICATED CreateAwsClusterRequestType = "DEDICATED"
	CreateAwsClusterRequestTypeHYBRID    CreateAwsClusterRequestType = "HYBRID"
)

// Defines values for CreateAzureClusterRequestCloudProvider.
const (
	CreateAzureClusterRequestCloudProviderAWS   CreateAzureClusterRequestCloudProvider = "AWS"
	CreateAzureClusterRequestCloudProviderAZURE CreateAzureClusterRequestCloudProvider = "AZURE"
	CreateAzureClusterRequestCloudProviderGCP   CreateAzureClusterRequestCloudProvider = "GCP"
)

// Defines values for CreateAzureClusterRequestType.
const (
	CreateAzureClusterRequestTypeDEDICATED CreateAzureClusterRequestType = "DEDICATED"
	CreateAzureClusterRequestTypeHYBRID    CreateAzureClusterRequestType = "HYBRID"
)

// Defines values for CreateDedicatedDeploymentRequestExecutor.
const (
	CreateDedicatedDeploymentRequestExecutorCELERY     CreateDedicatedDeploymentRequestExecutor = "CELERY"
	CreateDedicatedDeploymentRequestExecutorKUBERNETES CreateDedicatedDeploymentRequestExecutor = "KUBERNETES"
)

// Defines values for CreateDedicatedDeploymentRequestSchedulerSize.
const (
	CreateDedicatedDeploymentRequestSchedulerSizeLARGE  CreateDedicatedDeploymentRequestSchedulerSize = "LARGE"
	CreateDedicatedDeploymentRequestSchedulerSizeMEDIUM CreateDedicatedDeploymentRequestSchedulerSize = "MEDIUM"
	CreateDedicatedDeploymentRequestSchedulerSizeSMALL  CreateDedicatedDeploymentRequestSchedulerSize = "SMALL"
)

// Defines values for CreateDedicatedDeploymentRequestType.
const (
	CreateDedicatedDeploymentRequestTypeDEDICATED CreateDedicatedDeploymentRequestType = "DEDICATED"
	CreateDedicatedDeploymentRequestTypeHYBRID    CreateDedicatedDeploymentRequestType = "HYBRID"
	CreateDedicatedDeploymentRequestTypeSTANDARD  CreateDedicatedDeploymentRequestType = "STANDARD"
)

// Defines values for CreateGcpClusterRequestCloudProvider.
const (
	CreateGcpClusterRequestCloudProviderAWS   CreateGcpClusterRequestCloudProvider = "AWS"
	CreateGcpClusterRequestCloudProviderAZURE CreateGcpClusterRequestCloudProvider = "AZURE"
	CreateGcpClusterRequestCloudProviderGCP   CreateGcpClusterRequestCloudProvider = "GCP"
)

// Defines values for CreateGcpClusterRequestType.
const (
	CreateGcpClusterRequestTypeDEDICATED CreateGcpClusterRequestType = "DEDICATED"
	CreateGcpClusterRequestTypeHYBRID    CreateGcpClusterRequestType = "HYBRID"
)

// Defines values for CreateHybridDeploymentRequestExecutor.
const (
	CreateHybridDeploymentRequestExecutorCELERY     CreateHybridDeploymentRequestExecutor = "CELERY"
	CreateHybridDeploymentRequestExecutorKUBERNETES CreateHybridDeploymentRequestExecutor = "KUBERNETES"
)

// Defines values for CreateHybridDeploymentRequestType.
const (
	CreateHybridDeploymentRequestTypeDEDICATED CreateHybridDeploymentRequestType = "DEDICATED"
	CreateHybridDeploymentRequestTypeHYBRID    CreateHybridDeploymentRequestType = "HYBRID"
	CreateHybridDeploymentRequestTypeSTANDARD  CreateHybridDeploymentRequestType = "STANDARD"
)

// Defines values for CreateStandardDeploymentRequestCloudProvider.
const (
	CreateStandardDeploymentRequestCloudProviderAWS   CreateStandardDeploymentRequestCloudProvider = "AWS"
	CreateStandardDeploymentRequestCloudProviderAZURE CreateStandardDeploymentRequestCloudProvider = "AZURE"
	CreateStandardDeploymentRequestCloudProviderGCP   CreateStandardDeploymentRequestCloudProvider = "GCP"
)

// Defines values for CreateStandardDeploymentRequestExecutor.
const (
	CreateStandardDeploymentRequestExecutorCELERY     CreateStandardDeploymentRequestExecutor = "CELERY"
	CreateStandardDeploymentRequestExecutorKUBERNETES CreateStandardDeploymentRequestExecutor = "KUBERNETES"
)

// Defines values for CreateStandardDeploymentRequestSchedulerSize.
const (
	CreateStandardDeploymentRequestSchedulerSizeLARGE  CreateStandardDeploymentRequestSchedulerSize = "LARGE"
	CreateStandardDeploymentRequestSchedulerSizeMEDIUM CreateStandardDeploymentRequestSchedulerSize = "MEDIUM"
	CreateStandardDeploymentRequestSchedulerSizeSMALL  CreateStandardDeploymentRequestSchedulerSize = "SMALL"
)

// Defines values for CreateStandardDeploymentRequestType.
const (
	CreateStandardDeploymentRequestTypeDEDICATED CreateStandardDeploymentRequestType = "DEDICATED"
	CreateStandardDeploymentRequestTypeHYBRID    CreateStandardDeploymentRequestType = "HYBRID"
	CreateStandardDeploymentRequestTypeSTANDARD  CreateStandardDeploymentRequestType = "STANDARD"
)

// Defines values for DeploymentExecutor.
const (
	DeploymentExecutorCELERY     DeploymentExecutor = "CELERY"
	DeploymentExecutorKUBERNETES DeploymentExecutor = "KUBERNETES"
)

// Defines values for DeploymentSchedulerSize.
const (
	DeploymentSchedulerSizeLARGE  DeploymentSchedulerSize = "LARGE"
	DeploymentSchedulerSizeMEDIUM DeploymentSchedulerSize = "MEDIUM"
	DeploymentSchedulerSizeSMALL  DeploymentSchedulerSize = "SMALL"
)

// Defines values for DeploymentStatus.
const (
	DeploymentStatusCREATING    DeploymentStatus = "CREATING"
	DeploymentStatusDEPLOYING   DeploymentStatus = "DEPLOYING"
	DeploymentStatusHEALTHY     DeploymentStatus = "HEALTHY"
	DeploymentStatusHIBERNATING DeploymentStatus = "HIBERNATING"
	DeploymentStatusUNHEALTHY   DeploymentStatus = "UNHEALTHY"
	DeploymentStatusUNKNOWN     DeploymentStatus = "UNKNOWN"
)

// Defines values for DeploymentType.
const (
	DeploymentTypeDEDICATED DeploymentType = "DEDICATED"
	DeploymentTypeHYBRID    DeploymentType = "HYBRID"
	DeploymentTypeSTANDARD  DeploymentType = "STANDARD"
)

// Defines values for ManagedDomainStatus.
const (
	PENDING  ManagedDomainStatus = "PENDING"
	VERIFIED ManagedDomainStatus = "VERIFIED"
)

// Defines values for NodePoolCloudProvider.
const (
	NodePoolCloudProviderAWS   NodePoolCloudProvider = "AWS"
	NodePoolCloudProviderAZURE NodePoolCloudProvider = "AZURE"
	NodePoolCloudProviderGCP   NodePoolCloudProvider = "GCP"
)

// Defines values for OrganizationPaymentMethod.
const (
	AWSMARKETPLACE   OrganizationPaymentMethod = "AWS_MARKETPLACE"
	AZUREMARKETPLACE OrganizationPaymentMethod = "AZURE_MARKETPLACE"
	CREDITCARD       OrganizationPaymentMethod = "CREDIT_CARD"
	GCPMARKETPLACE   OrganizationPaymentMethod = "GCP_MARKETPLACE"
	INVOICE          OrganizationPaymentMethod = "INVOICE"
)

// Defines values for OrganizationProduct.
const (
	OrganizationProductHOSTED OrganizationProduct = "HOSTED"
	OrganizationProductHYBRID OrganizationProduct = "HYBRID"
)

// Defines values for OrganizationStatus.
const (
	ACTIVE    OrganizationStatus = "ACTIVE"
	INACTIVE  OrganizationStatus = "INACTIVE"
	SUSPENDED OrganizationStatus = "SUSPENDED"
)

// Defines values for OrganizationSupportPlan.
const (
	OrganizationSupportPlanBASIC            OrganizationSupportPlan = "BASIC"
	OrganizationSupportPlanBUSINESSCRITICAL OrganizationSupportPlan = "BUSINESS_CRITICAL"
	OrganizationSupportPlanPREMIUM          OrganizationSupportPlan = "PREMIUM"
	OrganizationSupportPlanSTANDARD         OrganizationSupportPlan = "STANDARD"
	OrganizationSupportPlanTRIAL            OrganizationSupportPlan = "TRIAL"
)

// Defines values for SchedulerMachineName.
const (
	SchedulerMachineNameLARGE  SchedulerMachineName = "LARGE"
	SchedulerMachineNameMEDIUM SchedulerMachineName = "MEDIUM"
	SchedulerMachineNameSMALL  SchedulerMachineName = "SMALL"
)

// Defines values for UpdateDedicatedClusterRequestClusterType.
const (
	UpdateDedicatedClusterRequestClusterTypeDEDICATED UpdateDedicatedClusterRequestClusterType = "DEDICATED"
)

// Defines values for UpdateDedicatedDeploymentRequestExecutor.
const (
	UpdateDedicatedDeploymentRequestExecutorCELERY     UpdateDedicatedDeploymentRequestExecutor = "CELERY"
	UpdateDedicatedDeploymentRequestExecutorKUBERNETES UpdateDedicatedDeploymentRequestExecutor = "KUBERNETES"
)

// Defines values for UpdateDedicatedDeploymentRequestSchedulerSize.
const (
	UpdateDedicatedDeploymentRequestSchedulerSizeLARGE  UpdateDedicatedDeploymentRequestSchedulerSize = "LARGE"
	UpdateDedicatedDeploymentRequestSchedulerSizeMEDIUM UpdateDedicatedDeploymentRequestSchedulerSize = "MEDIUM"
	UpdateDedicatedDeploymentRequestSchedulerSizeSMALL  UpdateDedicatedDeploymentRequestSchedulerSize = "SMALL"
)

// Defines values for UpdateDedicatedDeploymentRequestType.
const (
	UpdateDedicatedDeploymentRequestTypeDEDICATED UpdateDedicatedDeploymentRequestType = "DEDICATED"
	UpdateDedicatedDeploymentRequestTypeHYBRID    UpdateDedicatedDeploymentRequestType = "HYBRID"
	UpdateDedicatedDeploymentRequestTypeSTANDARD  UpdateDedicatedDeploymentRequestType = "STANDARD"
)

// Defines values for UpdateHybridClusterRequestClusterType.
const (
	UpdateHybridClusterRequestClusterTypeHYBRID UpdateHybridClusterRequestClusterType = "HYBRID"
)

// Defines values for UpdateHybridDeploymentRequestExecutor.
const (
	UpdateHybridDeploymentRequestExecutorCELERY     UpdateHybridDeploymentRequestExecutor = "CELERY"
	UpdateHybridDeploymentRequestExecutorKUBERNETES UpdateHybridDeploymentRequestExecutor = "KUBERNETES"
)

// Defines values for UpdateHybridDeploymentRequestType.
const (
	UpdateHybridDeploymentRequestTypeDEDICATED UpdateHybridDeploymentRequestType = "DEDICATED"
	UpdateHybridDeploymentRequestTypeHYBRID    UpdateHybridDeploymentRequestType = "HYBRID"
	UpdateHybridDeploymentRequestTypeSTANDARD  UpdateHybridDeploymentRequestType = "STANDARD"
)

// Defines values for UpdateStandardDeploymentRequestExecutor.
const (
	UpdateStandardDeploymentRequestExecutorCELERY     UpdateStandardDeploymentRequestExecutor = "CELERY"
	UpdateStandardDeploymentRequestExecutorKUBERNETES UpdateStandardDeploymentRequestExecutor = "KUBERNETES"
)

// Defines values for UpdateStandardDeploymentRequestSchedulerSize.
const (
	UpdateStandardDeploymentRequestSchedulerSizeLARGE  UpdateStandardDeploymentRequestSchedulerSize = "LARGE"
	UpdateStandardDeploymentRequestSchedulerSizeMEDIUM UpdateStandardDeploymentRequestSchedulerSize = "MEDIUM"
	UpdateStandardDeploymentRequestSchedulerSizeSMALL  UpdateStandardDeploymentRequestSchedulerSize = "SMALL"
)

// Defines values for UpdateStandardDeploymentRequestType.
const (
	UpdateStandardDeploymentRequestTypeDEDICATED UpdateStandardDeploymentRequestType = "DEDICATED"
	UpdateStandardDeploymentRequestTypeHYBRID    UpdateStandardDeploymentRequestType = "HYBRID"
	UpdateStandardDeploymentRequestTypeSTANDARD  UpdateStandardDeploymentRequestType = "STANDARD"
)

// Defines values for WorkerMachineName.
const (
	WorkerMachineNameA10 WorkerMachineName = "A10"
	WorkerMachineNameA20 WorkerMachineName = "A20"
	WorkerMachineNameA40 WorkerMachineName = "A40"
	WorkerMachineNameA5  WorkerMachineName = "A5"
	WorkerMachineNameA60 WorkerMachineName = "A60"
)

// Defines values for WorkerQueueRequestAstroMachine.
const (
	WorkerQueueRequestAstroMachineA10 WorkerQueueRequestAstroMachine = "A10"
	WorkerQueueRequestAstroMachineA20 WorkerQueueRequestAstroMachine = "A20"
	WorkerQueueRequestAstroMachineA40 WorkerQueueRequestAstroMachine = "A40"
	WorkerQueueRequestAstroMachineA5  WorkerQueueRequestAstroMachine = "A5"
	WorkerQueueRequestAstroMachineA60 WorkerQueueRequestAstroMachine = "A60"
)

// Defines values for ListOrganizationsParamsSupportPlan.
const (
	ListOrganizationsParamsSupportPlanBASIC            ListOrganizationsParamsSupportPlan = "BASIC"
	ListOrganizationsParamsSupportPlanBUSINESSCRITICAL ListOrganizationsParamsSupportPlan = "BUSINESS_CRITICAL"
	ListOrganizationsParamsSupportPlanPREMIUM          ListOrganizationsParamsSupportPlan = "PREMIUM"
	ListOrganizationsParamsSupportPlanSTANDARD         ListOrganizationsParamsSupportPlan = "STANDARD"
	ListOrganizationsParamsSupportPlanTRIAL            ListOrganizationsParamsSupportPlan = "TRIAL"
)

// Defines values for ListOrganizationsParamsProduct.
const (
	ListOrganizationsParamsProductHOSTED ListOrganizationsParamsProduct = "HOSTED"
	ListOrganizationsParamsProductHYBRID ListOrganizationsParamsProduct = "HYBRID"
)

// Defines values for ListOrganizationsParamsSorts.
const (
	ListOrganizationsParamsSortsCreatedAtAsc  ListOrganizationsParamsSorts = "createdAt:asc"
	ListOrganizationsParamsSortsCreatedAtDesc ListOrganizationsParamsSorts = "createdAt:desc"
	ListOrganizationsParamsSortsNameAsc       ListOrganizationsParamsSorts = "name:asc"
	ListOrganizationsParamsSortsNameDesc      ListOrganizationsParamsSorts = "name:desc"
	ListOrganizationsParamsSortsUpdatedAtAsc  ListOrganizationsParamsSorts = "updatedAt:asc"
	ListOrganizationsParamsSortsUpdatedAtDesc ListOrganizationsParamsSorts = "updatedAt:desc"
)

// Defines values for GetClusterOptionsParamsProvider.
const (
	GetClusterOptionsParamsProviderAWS   GetClusterOptionsParamsProvider = "AWS"
	GetClusterOptionsParamsProviderAZURE GetClusterOptionsParamsProvider = "AZURE"
	GetClusterOptionsParamsProviderGCP   GetClusterOptionsParamsProvider = "GCP"
)

// Defines values for GetClusterOptionsParamsType.
const (
	DEDICATED GetClusterOptionsParamsType = "DEDICATED"
	HYBRID    GetClusterOptionsParamsType = "HYBRID"
)

// Defines values for ListClustersParamsProvider.
const (
	ListClustersParamsProviderAWS   ListClustersParamsProvider = "AWS"
	ListClustersParamsProviderAZURE ListClustersParamsProvider = "AZURE"
	ListClustersParamsProviderGCP   ListClustersParamsProvider = "GCP"
)

// Defines values for ListClustersParamsSorts.
const (
	ListClustersParamsSortsCreatedAtAsc  ListClustersParamsSorts = "createdAt:asc"
	ListClustersParamsSortsCreatedAtDesc ListClustersParamsSorts = "createdAt:desc"
	ListClustersParamsSortsNameAsc       ListClustersParamsSorts = "name:asc"
	ListClustersParamsSortsNameDesc      ListClustersParamsSorts = "name:desc"
	ListClustersParamsSortsUpdatedAtAsc  ListClustersParamsSorts = "updatedAt:asc"
	ListClustersParamsSortsUpdatedAtDesc ListClustersParamsSorts = "updatedAt:desc"
)

// Defines values for GetDeploymentOptionsParamsDeploymentType.
const (
	GetDeploymentOptionsParamsDeploymentTypeDEDICATED GetDeploymentOptionsParamsDeploymentType = "DEDICATED"
	GetDeploymentOptionsParamsDeploymentTypeHYBRID    GetDeploymentOptionsParamsDeploymentType = "HYBRID"
	GetDeploymentOptionsParamsDeploymentTypeSTANDARD  GetDeploymentOptionsParamsDeploymentType = "STANDARD"
)

// Defines values for GetDeploymentOptionsParamsExecutor.
const (
	GetDeploymentOptionsParamsExecutorCELERY     GetDeploymentOptionsParamsExecutor = "CELERY"
	GetDeploymentOptionsParamsExecutorKUBERNETES GetDeploymentOptionsParamsExecutor = "KUBERNETES"
)

// Defines values for GetDeploymentOptionsParamsCloudProvider.
const (
	GetDeploymentOptionsParamsCloudProviderAWS   GetDeploymentOptionsParamsCloudProvider = "AWS"
	GetDeploymentOptionsParamsCloudProviderAZURE GetDeploymentOptionsParamsCloudProvider = "AZURE"
	GetDeploymentOptionsParamsCloudProviderGCP   GetDeploymentOptionsParamsCloudProvider = "GCP"
)

// Defines values for ListDeploymentsParamsSorts.
const (
	ListDeploymentsParamsSortsCreatedAtAsc  ListDeploymentsParamsSorts = "createdAt:asc"
	ListDeploymentsParamsSortsCreatedAtDesc ListDeploymentsParamsSorts = "createdAt:desc"
	ListDeploymentsParamsSortsNameAsc       ListDeploymentsParamsSorts = "name:asc"
	ListDeploymentsParamsSortsNameDesc      ListDeploymentsParamsSorts = "name:desc"
	ListDeploymentsParamsSortsUpdatedAtAsc  ListDeploymentsParamsSorts = "updatedAt:asc"
	ListDeploymentsParamsSortsUpdatedAtDesc ListDeploymentsParamsSorts = "updatedAt:desc"
)

// Defines values for ListWorkspacesParamsSorts.
const (
	ListWorkspacesParamsSortsCreatedAtAsc  ListWorkspacesParamsSorts = "createdAt:asc"
	ListWorkspacesParamsSortsCreatedAtDesc ListWorkspacesParamsSorts = "createdAt:desc"
	ListWorkspacesParamsSortsNameAsc       ListWorkspacesParamsSorts = "name:asc"
	ListWorkspacesParamsSortsNameDesc      ListWorkspacesParamsSorts = "name:desc"
	ListWorkspacesParamsSortsUpdatedAtAsc  ListWorkspacesParamsSorts = "updatedAt:asc"
	ListWorkspacesParamsSortsUpdatedAtDesc ListWorkspacesParamsSorts = "updatedAt:desc"
)

// BasicSubjectProfile defines model for BasicSubjectProfile.
type BasicSubjectProfile struct {
	// ApiTokenName The API token's name. Returned only when `SubjectType` is `SERVICEKEY`.
	ApiTokenName *string `json:"apiTokenName,omitempty"`

	// AvatarUrl The URL for the user's profile image. Returned only when `SubjectType` is `USER`.
	AvatarUrl *string `json:"avatarUrl,omitempty"`

	// FullName The subject's full name. Returned only when `SubjectType` is `USER`.
	FullName *string `json:"fullName,omitempty"`

	// Id The subject's ID.
	Id string `json:"id"`

	// SubjectType The subject type.
	SubjectType *BasicSubjectProfileSubjectType `json:"subjectType,omitempty"`

	// Username The subject's username. Returned only when `SubjectType` is `USER`.
	Username *string `json:"username,omitempty"`
}

// BasicSubjectProfileSubjectType The subject type.
type BasicSubjectProfileSubjectType string

// Cluster defines model for Cluster.
type Cluster struct {
	// CloudProvider The name of the cluster's cloud provider.
	CloudProvider ClusterCloudProvider `json:"cloudProvider"`

	// CreatedAt The time when the cluster was created in UTC. formatted as `YYYY-MM-DDTHH:MM:SSZ`.
	CreatedAt time.Time `json:"createdAt"`

	// DbInstanceType The type of database instance that is used for the cluster.
	DbInstanceType string `json:"dbInstanceType"`

	// Id The cluster's ID.
	Id string `json:"id"`

	// IsLimited Whether the cluster is limited.
	IsLimited *bool            `json:"isLimited,omitempty"`
	Metadata  *ClusterMetadata `json:"metadata,omitempty"`

	// Name The cluster's name.
	Name string `json:"name"`

	// NodePools The list of node pools that are created in the cluster.
	NodePools *[]NodePool `json:"nodePools,omitempty"`

	// OrganizationId The ID of the Organization that the cluster belongs to.
	OrganizationId string `json:"organizationId"`

	// PodSubnetRange The subnet range for Pods. For GCP clusters only.
	PodSubnetRange *string `json:"podSubnetRange,omitempty"`

	// ProviderAccount The provider account ID. For GCP clusters only.
	ProviderAccount *string `json:"providerAccount,omitempty"`

	// Region The region in which the cluster is created.
	Region string `json:"region"`

	// ServicePeeringRange The service peering range. For GCP clusters only.
	ServicePeeringRange *string `json:"servicePeeringRange,omitempty"`

	// ServiceSubnetRange The service subnet range. For GCP clusters only.
	ServiceSubnetRange *string `json:"serviceSubnetRange,omitempty"`

	// Status The status of the cluster.
	Status ClusterStatus `json:"status"`

	// Tags The Kubernetes tags in the cluster. For AWS Hybrid clusters only.
	Tags *[]ClusterK8sTag `json:"tags,omitempty"`

	// TenantId The tenant ID. For Azure clusters only.
	TenantId *string `json:"tenantId,omitempty"`

	// Type The type of the cluster.
	Type ClusterType `json:"type"`

	// UpdatedAt The time when the cluster was last updated in UTC. formatted as `YYYY-MM-DDTHH:MM:SSZ`.
	UpdatedAt time.Time `json:"updatedAt"`

	// VpcSubnetRange The VPC subnet range.
	VpcSubnetRange string `json:"vpcSubnetRange"`

	// WorkspaceIds The list of Workspaces that are authorized to the cluster.
	WorkspaceIds *[]string `json:"workspaceIds,omitempty"`
}

// ClusterCloudProvider The name of the cluster's cloud provider.
type ClusterCloudProvider string

// ClusterStatus The status of the cluster.
type ClusterStatus string

// ClusterType The type of the cluster.
type ClusterType string

// ClusterK8sTag defines model for ClusterK8sTag.
type ClusterK8sTag struct {
	// Key The tag's key.
	Key *string `json:"key,omitempty"`

	// Value The tag's value.
	Value *string `json:"value,omitempty"`
}

// ClusterMetadata defines model for ClusterMetadata.
type ClusterMetadata struct {
	// ExternalIPs External IPs of the cluster.
	ExternalIPs *[]string `json:"externalIPs,omitempty"`

	// OidcIssuerUrl OIDC issuer URL for the cluster
	OidcIssuerUrl *string `json:"oidcIssuerUrl,omitempty"`
}

// ClusterOptions defines model for ClusterOptions.
type ClusterOptions struct {
	// DatabaseInstances The available database instances.
	DatabaseInstances       []ProviderInstanceType `json:"databaseInstances"`
	DefaultDatabaseInstance ProviderInstanceType   `json:"defaultDatabaseInstance"`
	DefaultNodeInstance     ProviderInstanceType   `json:"defaultNodeInstance"`

	// DefaultPodSubnetRange The default pod subnet range.
	DefaultPodSubnetRange *string        `json:"defaultPodSubnetRange,omitempty"`
	DefaultRegion         ProviderRegion `json:"defaultRegion"`

	// DefaultServicePeeringRange The default service peering range.
	DefaultServicePeeringRange *string `json:"defaultServicePeeringRange,omitempty"`

	// DefaultServiceSubnetRange The default service subnet range.
	DefaultServiceSubnetRange *string `json:"defaultServiceSubnetRange,omitempty"`

	// DefaultVpcSubnetRange The default VPC subnet range.
	DefaultVpcSubnetRange string `json:"defaultVpcSubnetRange"`

	// NodeCountDefault The default number of nodes.
	NodeCountDefault int `json:"nodeCountDefault"`

	// NodeCountMax The maximum number of nodes.
	NodeCountMax int `json:"nodeCountMax"`

	// NodeCountMin The minimum number of nodes.
	NodeCountMin int `json:"nodeCountMin"`

	// NodeInstances The available node instances.
	NodeInstances []ProviderInstanceType `json:"nodeInstances"`

	// Provider The cloud provider.
	Provider ClusterOptionsProvider `json:"provider"`

	// Regions The available regions.
	Regions []ProviderRegion `json:"regions"`
}

// ClusterOptionsProvider The cloud provider.
type ClusterOptionsProvider string

// ClustersPaginated defines model for ClustersPaginated.
type ClustersPaginated struct {
	// Clusters The list of clusters in the current page.
	Clusters []Cluster `json:"clusters"`

	// Limit The maximum number of clusters in one page.
	Limit int `json:"limit"`

	// Offset The offset of the current page of clusters.
	Offset int `json:"offset"`

	// TotalCount The total number of clusters.
	TotalCount int `json:"totalCount"`
}

// CreateAwsClusterRequest defines model for CreateAwsClusterRequest.
type CreateAwsClusterRequest struct {
	// CloudProvider The cluster's cloud provider.
	CloudProvider CreateAwsClusterRequestCloudProvider `json:"cloudProvider"`

	// DbInstanceType The type of database instance that is used for the cluster. Required for Hybrid clusters.
	DbInstanceType *string `json:"dbInstanceType,omitempty"`

	// K8sTags The Kubernetes tags in the cluster.
	K8sTags *[]ClusterK8sTag `json:"k8sTags,omitempty"`

	// Name The cluster's name.
	Name string `json:"name"`

	// NodePools The list of node pools to create in the cluster.
	NodePools *[]CreateNodePoolRequest `json:"nodePools,omitempty"`

	// ProviderAccount The provider account ID. Required for Hybrid clusters.
	ProviderAccount *string `json:"providerAccount,omitempty"`

	// Region The cluster's region.
	Region string `json:"region"`

	// Type The cluster's type.
	Type CreateAwsClusterRequestType `json:"type"`

	// VpcSubnetRange The VPC subnet range.
	VpcSubnetRange string `json:"vpcSubnetRange"`

	// WorkspaceIds The list of Workspaces that are authorized to the cluster.
	WorkspaceIds *[]string `json:"workspaceIds,omitempty"`
}

// CreateAwsClusterRequestCloudProvider The cluster's cloud provider.
type CreateAwsClusterRequestCloudProvider string

// CreateAwsClusterRequestType The cluster's type.
type CreateAwsClusterRequestType string

// CreateAzureClusterRequest defines model for CreateAzureClusterRequest.
type CreateAzureClusterRequest struct {
	// CloudProvider The cluster's cloud provider.
	CloudProvider CreateAzureClusterRequestCloudProvider `json:"cloudProvider"`

	// DbInstanceType The type of database instance that is used for the cluster. Required for Hybrid clusters.
	DbInstanceType *string `json:"dbInstanceType,omitempty"`

	// K8sTags The Kubernetes tags in the cluster.
	K8sTags *[]ClusterK8sTag `json:"k8sTags,omitempty"`

	// Name The cluster's name.
	Name string `json:"name"`

	// NodePools The list of node pools to create in the cluster.
	NodePools *[]CreateNodePoolRequest `json:"nodePools,omitempty"`

	// ProviderAccount The provider account ID. Required for Hybrid clusters.
	ProviderAccount *string `json:"providerAccount,omitempty"`

	// Region The cluster's region.
	Region string `json:"region"`

	// TenantId The tenant ID. For Azure clusters only.
	TenantId *string `json:"tenantId,omitempty"`

	// Type The cluster's type.
	Type CreateAzureClusterRequestType `json:"type"`

	// VpcSubnetRange The VPC subnet range.
	VpcSubnetRange string `json:"vpcSubnetRange"`

	// WorkspaceIds The list of Workspaces that are authorized to the cluster.
	WorkspaceIds *[]string `json:"workspaceIds,omitempty"`
}

// CreateAzureClusterRequestCloudProvider The cluster's cloud provider.
type CreateAzureClusterRequestCloudProvider string

// CreateAzureClusterRequestType The cluster's type.
type CreateAzureClusterRequestType string

// CreateClusterRequest defines model for CreateClusterRequest.
type CreateClusterRequest struct {
	union json.RawMessage
}

// CreateDedicatedDeploymentRequest defines model for CreateDedicatedDeploymentRequest.
type CreateDedicatedDeploymentRequest struct {
	// AstroRuntimeVersion Deployment's Astro Runtime version.
	AstroRuntimeVersion string `json:"astroRuntimeVersion"`

	// ClusterId The ID of the cluster where the Deployment will be created.
	ClusterId string `json:"clusterId"`

	// DefaultTaskPodCpu The default CPU resource usage for a worker Pod when running the Kubernetes executor or KubernetesPodOperator. Units are in number of CPU cores.
	DefaultTaskPodCpu string `json:"defaultTaskPodCpu"`

	// DefaultTaskPodMemory The default memory resource usage for a worker Pod when running the Kubernetes executor or KubernetesPodOperator. Units are in `Gi`. This value must always be twice the value of `DefaultTaskPodCpu`.
	DefaultTaskPodMemory string `json:"defaultTaskPodMemory"`

	// Description The Deployment's description.
	Description *string `json:"description,omitempty"`

	// Executor The Deployment's executor type.
	Executor CreateDedicatedDeploymentRequestExecutor `json:"executor"`

	// IsCicdEnforced Whether the Deployment requires that all deploys are made through CI/CD.
	IsCicdEnforced bool `json:"isCicdEnforced"`

	// IsDagDeployEnabled Whether the Deployment has DAG deploys enabled.
	IsDagDeployEnabled bool `json:"isDagDeployEnabled"`

	// IsHighAvailability Whether the Deployment is configured for high availability. If `true`, multiple scheduler pods will be online.
	IsHighAvailability bool `json:"isHighAvailability"`

	// Name The Deployment's name.
	Name string `json:"name"`

	// ResourceQuotaCpu The CPU quota for worker Pods when running the Kubernetes executor or KubernetesPodOperator. If current CPU usage across all workers exceeds the quota, no new worker Pods can be scheduled. Units are in number of CPU cores.
	ResourceQuotaCpu string `json:"resourceQuotaCpu"`

	// ResourceQuotaMemory The memory quota for worker Pods when running the Kubernetes executor or KubernetesPodOperator. If current memory usage across all workers exceeds the quota, no new worker Pods can be scheduled. Units are in `Gi`. This value must always be twice the value of `ResourceQuotaCpu`.
	ResourceQuotaMemory string `json:"resourceQuotaMemory"`

	// SchedulerSize The size of the scheduler pod.
	SchedulerSize CreateDedicatedDeploymentRequestSchedulerSize `json:"schedulerSize"`

	// Type The type of the Deployment.
	Type CreateDedicatedDeploymentRequestType `json:"type"`

	// WorkerQueues The list of worker queues configured for the Deployment. Applies only when `Executor` is `CELERY`. At least 1 worker queue is needed. All Deployments need at least 1 worker queue called `default`.
	WorkerQueues *[]WorkerQueueRequest `json:"workerQueues,omitempty"`

	// WorkspaceId The ID of the workspace to which the Deployment belongs.
	WorkspaceId string `json:"workspaceId"`
}

// CreateDedicatedDeploymentRequestExecutor The Deployment's executor type.
type CreateDedicatedDeploymentRequestExecutor string

// CreateDedicatedDeploymentRequestSchedulerSize The size of the scheduler pod.
type CreateDedicatedDeploymentRequestSchedulerSize string

// CreateDedicatedDeploymentRequestType The type of the Deployment.
type CreateDedicatedDeploymentRequestType string

// CreateDeploymentRequest defines model for CreateDeploymentRequest.
type CreateDeploymentRequest struct {
	union json.RawMessage
}

// CreateGcpClusterRequest defines model for CreateGcpClusterRequest.
type CreateGcpClusterRequest struct {
	// CloudProvider The cluster's cloud provider.
	CloudProvider CreateGcpClusterRequestCloudProvider `json:"cloudProvider"`

	// DbInstanceType The type of database instance that is used for the cluster. Required for Hybrid clusters.
	DbInstanceType *string `json:"dbInstanceType,omitempty"`

	// K8sTags The Kubernetes tags in the cluster.
	K8sTags *[]ClusterK8sTag `json:"k8sTags,omitempty"`

	// Name The cluster's name.
	Name string `json:"name"`

	// NodePools The list of node pools to create in the cluster.
	NodePools *[]CreateNodePoolRequest `json:"nodePools,omitempty"`

	// PodSubnetRange The subnet range for Pods. For GCP clusters only.
	PodSubnetRange string `json:"podSubnetRange"`

	// ProviderAccount The provider account ID. Required for Hybrid clusters.
	ProviderAccount *string `json:"providerAccount,omitempty"`

	// Region The cluster's region.
	Region string `json:"region"`

	// ServicePeeringRange The service subnet range. For GCP clusters only.
	ServicePeeringRange string `json:"servicePeeringRange"`

	// ServiceSubnetRange The service peering range. For GCP clusters only.
	ServiceSubnetRange string `json:"serviceSubnetRange"`

	// Type The cluster's type.
	Type CreateGcpClusterRequestType `json:"type"`

	// VpcSubnetRange The VPC subnet range.
	VpcSubnetRange string `json:"vpcSubnetRange"`

	// WorkspaceIds The list of Workspaces that are authorized to the cluster.
	WorkspaceIds *[]string `json:"workspaceIds,omitempty"`
}

// CreateGcpClusterRequestCloudProvider The cluster's cloud provider.
type CreateGcpClusterRequestCloudProvider string

// CreateGcpClusterRequestType The cluster's type.
type CreateGcpClusterRequestType string

// CreateHybridDeploymentRequest defines model for CreateHybridDeploymentRequest.
type CreateHybridDeploymentRequest struct {
	// AstroRuntimeVersion Deployment's Astro Runtime version.
	AstroRuntimeVersion string `json:"astroRuntimeVersion"`

	// ClusterId The ID of the cluster where the Deployment will be created.
	ClusterId string `json:"clusterId"`

	// Description The Deployment's description.
	Description *string `json:"description,omitempty"`

	// Executor The Deployment's executor type.
	Executor CreateHybridDeploymentRequestExecutor `json:"executor"`

	// IsCicdEnforced Whether the Deployment requires that all deploys are made through CI/CD.
	IsCicdEnforced bool `json:"isCicdEnforced"`

	// IsDagDeployEnabled Whether the Deployment has DAG deploys enabled.
	IsDagDeployEnabled bool `json:"isDagDeployEnabled"`

	// Name The Deployment's name.
	Name      string                        `json:"name"`
	Scheduler DeploymentInstanceSpecRequest `json:"scheduler"`

	// TaskPodNodePoolId The node pool ID for the task pods. For `KUBERNETES` executor only.
	TaskPodNodePoolId *string `json:"taskPodNodePoolId,omitempty"`

	// Type The type of the Deployment.
	Type CreateHybridDeploymentRequestType `json:"type"`

	// WorkerQueues The list of worker queues configured for the Deployment. Applies only when `Executor` is `CELERY`. At least 1 worker queue is needed. All Deployments need at least 1 worker queue called `default`.
	WorkerQueues *[]HybridWorkerQueueRequest `json:"workerQueues,omitempty"`

	// WorkspaceId The ID of the workspace to which the Deployment belongs.
	WorkspaceId string `json:"workspaceId"`
}

// CreateHybridDeploymentRequestExecutor The Deployment's executor type.
type CreateHybridDeploymentRequestExecutor string

// CreateHybridDeploymentRequestType The type of the Deployment.
type CreateHybridDeploymentRequestType string

// CreateNodePoolRequest defines model for CreateNodePoolRequest.
type CreateNodePoolRequest struct {
	// IsDefault Whether the node pool is the default node pool of the cluster.
	IsDefault *bool `json:"isDefault,omitempty"`

	// MaxNodeCount The maximum number of nodes that can be created in the node pool.
	MaxNodeCount int `json:"maxNodeCount"`

	// Name The name of the node pool.
	Name string `json:"name"`

	// NodeInstanceType The type of node instance that is used for the node pool.
	NodeInstanceType string `json:"nodeInstanceType"`
}

// CreateStandardDeploymentRequest defines model for CreateStandardDeploymentRequest.
type CreateStandardDeploymentRequest struct {
	// AstroRuntimeVersion Deployment's Astro Runtime version.
	AstroRuntimeVersion string `json:"astroRuntimeVersion"`

	// CloudProvider The cloud provider for the Deployment's cluster. Optional if `ClusterId` is specified.
	CloudProvider *CreateStandardDeploymentRequestCloudProvider `json:"cloudProvider,omitempty"`

	// ClusterId The ID of the cluster to which the Deployment will be created in. Optional if cloud provider and region is specified.
	ClusterId *string `json:"clusterId,omitempty"`

	// DefaultTaskPodCpu The default CPU resource usage for a worker Pod when running the Kubernetes executor or KubernetesPodOperator. Units are in number of CPU cores.
	DefaultTaskPodCpu string `json:"defaultTaskPodCpu"`

	// DefaultTaskPodMemory The default memory resource usage for a worker Pod when running the Kubernetes executor or KubernetesPodOperator. Units are in `Gi`. This value must always be twice the value of `DefaultTaskPodCpu`.
	DefaultTaskPodMemory string `json:"defaultTaskPodMemory"`

	// Description The Deployment's description.
	Description *string `json:"description,omitempty"`

	// Executor The Deployment's executor type.
	Executor CreateStandardDeploymentRequestExecutor `json:"executor"`

	// IsCicdEnforced Whether the Deployment requires that all deploys are made through CI/CD.
	IsCicdEnforced bool `json:"isCicdEnforced"`

	// IsDagDeployEnabled Whether the Deployment has DAG deploys enabled.
	IsDagDeployEnabled bool `json:"isDagDeployEnabled"`

	// IsHighAvailability Whether the Deployment is configured for high availability. If `true`, multiple scheduler pods will be online.
	IsHighAvailability bool `json:"isHighAvailability"`

	// Name The Deployment's name.
	Name string `json:"name"`

	// Region The region to host the Deployment in. Optional if `ClusterId` is specified.
	Region *string `json:"region,omitempty"`

	// ResourceQuotaCpu The CPU quota for worker Pods when running the Kubernetes executor or KubernetesPodOperator. If current CPU usage across all workers exceeds the quota, no new worker Pods can be scheduled. Units are in number of CPU cores.
	ResourceQuotaCpu string `json:"resourceQuotaCpu"`

	// ResourceQuotaMemory The memory quota for worker Pods when running the Kubernetes executor or KubernetesPodOperator. If current memory usage across all workers exceeds the quota, no new worker Pods can be scheduled. Units are in `Gi`. This value must always be twice the value of `ResourceQuotaCpu`.
	ResourceQuotaMemory string `json:"resourceQuotaMemory"`

	// SchedulerSize The size of the scheduler pod.
	SchedulerSize CreateStandardDeploymentRequestSchedulerSize `json:"schedulerSize"`

	// Type The type of the Deployment.
	Type CreateStandardDeploymentRequestType `json:"type"`

	// WorkerQueues The list of worker queues configured for the Deployment. Applies only when `Executor` is `CELERY`. At least 1 worker queue is needed. All Deployments need at least 1 worker queue called `default`.
	WorkerQueues *[]WorkerQueueRequest `json:"workerQueues,omitempty"`

	// WorkspaceId The ID of the workspace to which the Deployment belongs.
	WorkspaceId string `json:"workspaceId"`
}

// CreateStandardDeploymentRequestCloudProvider The cloud provider for the Deployment's cluster. Optional if `ClusterId` is specified.
type CreateStandardDeploymentRequestCloudProvider string

// CreateStandardDeploymentRequestExecutor The Deployment's executor type.
type CreateStandardDeploymentRequestExecutor string

// CreateStandardDeploymentRequestSchedulerSize The size of the scheduler pod.
type CreateStandardDeploymentRequestSchedulerSize string

// CreateStandardDeploymentRequestType The type of the Deployment.
type CreateStandardDeploymentRequestType string

// CreateWorkspaceRequest defines model for CreateWorkspaceRequest.
type CreateWorkspaceRequest struct {
	// CicdEnforcedDefault Whether new Deployments enforce CI/CD deploys by default.
	CicdEnforcedDefault *bool `json:"cicdEnforcedDefault,omitempty"`

	// Description The Workspace's description.
	Description *string `json:"description,omitempty"`

	// Name The Workspace's name.
	Name string `json:"name"`
}

// Deployment defines model for Deployment.
type Deployment struct {
	// AirflowVersion The Deployment's Astro Runtime version.
	AirflowVersion string `json:"airflowVersion"`

	// CloudProvider The cloud provider of the cluster. Only for Standard Deployment.
	CloudProvider *string `json:"cloudProvider,omitempty"`

	// ClusterId The ID of the cluster where the Deployment is hosted.
	ClusterId *string `json:"clusterId,omitempty"`

	// ClusterName The name of the cluster where the Deployment is hosted. Only for Dedicated and Hybrid Deployments.
	ClusterName *string `json:"clusterName,omitempty"`

	// ContactEmails The list of contact emails for the Deployment.
	ContactEmails *[]string `json:"contactEmails,omitempty"`

	// CreatedAt The time when the Deployment was created in UTC, formatted as `YYYY-MM-DDTHH:MM:SSZ`.
	CreatedAt time.Time           `json:"createdAt"`
	CreatedBy BasicSubjectProfile `json:"createdBy"`

	// DagTarballVersion The Deployment's current DAG tarball version, also known as the Bundle Version in the Cloud UI. If no deploys are currently processing, this value should be the same as DesiredDagTarballVersion.
	DagTarballVersion *string `json:"dagTarballVersion,omitempty"`

	// DefaultTaskPodCpu The default CPU resource usage for a worker Pod when running the Kubernetes executor or KubernetesPodOperator. Units are in number of CPU cores.
	DefaultTaskPodCpu *string `json:"defaultTaskPodCpu,omitempty"`

	// DefaultTaskPodMemory The default memory resource usage for a worker Pod when running the Kubernetes executor or KubernetesPodOperator. Units are in `Gi`. This value must always be twice the value of `DefaultTaskPodCpu`.
	DefaultTaskPodMemory *string `json:"defaultTaskPodMemory,omitempty"`

	// Description The Deployment's description.
	Description *string `json:"description,omitempty"`

	// DesiredDagTarballVersion The Deployment's expected DAG tarball version after a currently processing deploy completes. This value is updated when a user triggers a DAG-only deploy to indicate that the Deployment is expecting a new DAG tarball version. If no deploys are currently processing, this value should be the same as DagTarballVersion.
	DesiredDagTarballVersion *string `json:"desiredDagTarballVersion,omitempty"`

	// EnvironmentVariables The Deployment's environment variables. Secret values will be omitted from response.
	EnvironmentVariables *[]DeploymentEnvironmentVariable `json:"environmentVariables,omitempty"`

	// Executor The Deployment's executor type.
	Executor *DeploymentExecutor `json:"executor,omitempty"`

	// ExternalIPs A list of the Deployment's external IPs.
	ExternalIPs *[]string `json:"externalIPs,omitempty"`

	// Id The Deployment's ID.
	Id string `json:"id"`

	// ImageRepository The URL of the Deployment's image repository.
	ImageRepository string `json:"imageRepository"`

	// ImageTag The Deployment's custom image tag. Appears only if specified in the most recent deploy.
	ImageTag string `json:"imageTag"`

	// ImageVersion A tag that Astronomer applies to the Deployment's Astro Runtime image during a deploy. It includes the date and time of the deploy.
	ImageVersion *string `json:"imageVersion,omitempty"`

	// IsCicdEnforced Whether the Deployment requires that all deploys are made through CI/CD.
	IsCicdEnforced bool `json:"isCicdEnforced"`

	// IsDagDeployEnabled Whether the Deployment has DAG deploys enabled.
	IsDagDeployEnabled bool `json:"isDagDeployEnabled"`

	// IsHighAvailability Whether the Deployment has high availability (HA) enabled. If `true`, multiple scheduler Pods will run at once.
	IsHighAvailability *bool `json:"isHighAvailability,omitempty"`

	// Name The Deployment's name.
	Name string `json:"name"`

	// Namespace The Deployment's namespace name in the Kubernetes cluster.
	Namespace string `json:"namespace"`

	// OidcIssuerUrl OIDC issuer URL of the deployment's cluster
	OidcIssuerUrl *string `json:"oidcIssuerUrl,omitempty"`

	// OrganizationId The ID of the Organization to which the Deployment belongs.
	OrganizationId string `json:"organizationId"`

	// Region The region of the cluster. Only for Dedicated and Hybrid Deployments.
	Region *string `json:"region,omitempty"`

	// ResourceQuotaCpu The CPU quota for worker Pods when running the Kubernetes executor or KubernetesPodOperator. If current CPU usage across all workers exceeds the quota, no new worker Pods can be scheduled. Units are in number of CPU cores.
	ResourceQuotaCpu *string `json:"resourceQuotaCpu,omitempty"`

	// ResourceQuotaMemory The memory quota for worker Pods when running the Kubernetes executor or KubernetesPodOperator. If current memory usage across all workers exceeds the quota, no new worker Pods can be scheduled. Units are in `Gi`. This value must always be twice the value of `ResourceQuotaCpu`.
	ResourceQuotaMemory *string `json:"resourceQuotaMemory,omitempty"`

	// RuntimeVersion The Deployment's Astro Runtime version.
	RuntimeVersion string `json:"runtimeVersion"`

	// SchedulerAu The number of Astronomer units (AU) for the Deployment's scheduler. Applies only to Deployments hosted on Hybrid clusters.
	SchedulerAu *int `json:"schedulerAu,omitempty"`

	// SchedulerCpu The CPU limit for the Deployment's scheduler. Specified in number of CPU cores.
	SchedulerCpu string `json:"schedulerCpu"`

	// SchedulerMemory The memory limit for the Deployment's scheduler. Units in Gibibytes or `Gi`.
	SchedulerMemory string `json:"schedulerMemory"`

	// SchedulerReplicas The number of schedulers to use in the Deployment.
	SchedulerReplicas int `json:"schedulerReplicas"`

	// SchedulerSize The Deployment's scheduler size.
	SchedulerSize *DeploymentSchedulerSize `json:"schedulerSize,omitempty"`

	// Status The status of the Deployment.
	Status DeploymentStatus `json:"status"`

	// StatusReason A message that provides context for the Deployment's status.
	StatusReason *string `json:"statusReason,omitempty"`

	// TaskPodNodePoolId The node pool ID for the task pod.
	TaskPodNodePoolId *string `json:"taskPodNodePoolId,omitempty"`

	// Type The type of cluster that the Deployment runs on.
	Type *DeploymentType `json:"type,omitempty"`

	// UpdatedAt The time when the Deployment was last updated in UTC, formatted as `YYYY-MM-DDTHH:MM:SSZ`.
	UpdatedAt time.Time           `json:"updatedAt"`
	UpdatedBy BasicSubjectProfile `json:"updatedBy"`

	// WebServerAirflowApiUrl The Deployment's webserver's base url to directly access the Airflow api.
	WebServerAirflowApiUrl string `json:"webServerAirflowApiUrl"`

	// WebServerCpu The CPU limit for the Deployment's webserver. Units are in number of CPU cores.
	WebServerCpu string `json:"webServerCpu"`

	// WebServerIngressHostname The Deployment's webserver's ingress hostname.
	WebServerIngressHostname string `json:"webServerIngressHostname"`

	// WebServerMemory The memory limit for the Deployment's webserver. Units in Gibibytes or `Gi`.
	WebServerMemory string `json:"webServerMemory"`

	// WebServerReplicas The number of webserver replicas.
	WebServerReplicas *int `json:"webServerReplicas,omitempty"`

	// WebServerUrl The Deployment's webserver's url.
	WebServerUrl string `json:"webServerUrl"`

	// WorkerQueues A list of the Deployment's worker queues.
	WorkerQueues *[]WorkerQueue `json:"workerQueues,omitempty"`

	// WorkloadIdentity The Deployment's workload identity.
	WorkloadIdentity *string `json:"workloadIdentity,omitempty"`

	// WorkspaceId The ID of the Workspace to which the Deployment belongs.
	WorkspaceId string `json:"workspaceId"`

	// WorkspaceName The name of the Workspace to which the Deployment belongs.
	WorkspaceName *string `json:"workspaceName,omitempty"`
}

// DeploymentExecutor The Deployment's executor type.
type DeploymentExecutor string

// DeploymentSchedulerSize The Deployment's scheduler size.
type DeploymentSchedulerSize string

// DeploymentStatus The status of the Deployment.
type DeploymentStatus string

// DeploymentType The type of cluster that the Deployment runs on.
type DeploymentType string

// DeploymentEnvironmentVariable defines model for DeploymentEnvironmentVariable.
type DeploymentEnvironmentVariable struct {
	// IsSecret Whether the environment variable is a secret.
	IsSecret bool `json:"isSecret"`

	// Key The environment variable key, used to call the value in code.
	Key string `json:"key"`

	// UpdatedAt The time when the environment variable was last updated in UTC, formatted as `YYYY-MM-DDTHH:MM:SSZ`.
	UpdatedAt string `json:"updatedAt"`

	// Value The environment variable value.
	Value *string `json:"value,omitempty"`
}

// DeploymentEnvironmentVariableRequest defines model for DeploymentEnvironmentVariableRequest.
type DeploymentEnvironmentVariableRequest struct {
	// IsSecret Whether the environment variable is a secret.
	IsSecret bool `json:"isSecret"`

	// Key The environment variable key, used to call the value in code.
	Key string `json:"key"`

	// Value The environment variable value.
	Value *string `json:"value,omitempty"`
}

// DeploymentInstanceSpecRequest defines model for DeploymentInstanceSpecRequest.
type DeploymentInstanceSpecRequest struct {
	// Au The number of Astro unit allocated to the Deployment pod. Minimum `5`, Maximum `24`.
	Au int `json:"au"`

	// Replicas The number of replicas the pod should have. Minimum `1`, Maximum `4`.
	Replicas int `json:"replicas"`
}

// DeploymentOptions defines model for DeploymentOptions.
type DeploymentOptions struct {
	// Executors The available executors.
	Executors      []string             `json:"executors"`
	ResourceQuotas ResourceQuotaOptions `json:"resourceQuotas"`

	// RuntimeReleases The available Astro Runtime versions.
	RuntimeReleases []RuntimeRelease `json:"runtimeReleases"`

	// SchedulerMachines The available scheduler sizes.
	SchedulerMachines []SchedulerMachine `json:"schedulerMachines"`

	// WorkerMachines The available worker machine types.
	WorkerMachines []WorkerMachine    `json:"workerMachines"`
	WorkerQueues   WorkerQueueOptions `json:"workerQueues"`

	// WorkloadIdentityOptions The available workload identity options.
	WorkloadIdentityOptions *[]WorkloadIdentityOption `json:"workloadIdentityOptions,omitempty"`
}

// DeploymentsPaginated defines model for DeploymentsPaginated.
type DeploymentsPaginated struct {
	// Deployments A list of Deployments in the current page.
	Deployments []Deployment `json:"deployments"`

	// Limit The maximum number of Deployments in one page.
	Limit int `json:"limit"`

	// Offset The offset of the current page of Deployments.
	Offset int `json:"offset"`

	// TotalCount The total number of Deployments.
	TotalCount int `json:"totalCount"`
}

// Error defines model for Error.
type Error struct {
	Message    string `json:"message"`
	RequestId  string `json:"requestId"`
	StatusCode int    `json:"statusCode"`
}

// HybridWorkerQueueRequest defines model for HybridWorkerQueueRequest.
type HybridWorkerQueueRequest struct {
	// Id The worker queue's ID. If not provided, a new worker queue will be created.
	Id *string `json:"id,omitempty"`

	// IsDefault Whether the worker queue is the default worker queue on the Deployment.
	IsDefault bool `json:"isDefault"`

	// MaxWorkerCount The maximum number of workers that can run at once.
	MaxWorkerCount int `json:"maxWorkerCount"`

	// MinWorkerCount The minimum number of workers running at once.
	MinWorkerCount int `json:"minWorkerCount"`

	// Name The worker queue's name.
	Name string `json:"name"`

	// NodePoolId The node pool ID associated with the worker queue.
	NodePoolId string `json:"nodePoolId"`

	// WorkerConcurrency The maximum number of concurrent tasks that a worker Pod can run at a time.
	WorkerConcurrency int `json:"workerConcurrency"`
}

// MachineSpec defines model for MachineSpec.
type MachineSpec struct {
	// Concurrency The maximum number of tasks that a given machine instance can run at once.
	Concurrency *float32 `json:"concurrency,omitempty"`

	// Cpu The CPU quantity. Units are in number of CPU cores.
	Cpu string `json:"cpu"`

	// EphemeralStorage The ephemeral storage quantity. Units in Gibibytes or `Gi`.
	EphemeralStorage *string `json:"ephemeralStorage,omitempty"`

	// Memory The memory quantity. Units in Gibibytes or `Gi`.
	Memory string `json:"memory"`
}

// ManagedDomain defines model for ManagedDomain.
type ManagedDomain struct {
	// CreatedAt The time when the domain was created in UTC, formatted as `YYYY-MM-DDTHH:MM:SSZ`.
	CreatedAt time.Time `json:"createdAt"`

	// EnforcedLogins A list of login types that are enforced for users belonging to the domain.
	EnforcedLogins *[]string `json:"enforcedLogins,omitempty"`

	// Id The managed domain's ID.
	Id string `json:"id"`

	// Name The managed domain's name/ URL.
	Name string `json:"name"`

	// OrganizationId The ID of the Organization to which the managed domain belongs.
	OrganizationId string `json:"organizationId"`

	// Status Whether the managed domain has completed the verification process.
	Status ManagedDomainStatus `json:"status"`

	// UpdatedAt The time when the domain was last updated in UTC, formatted as `YYYY-MM-DDTHH:MM:SSZ`.
	UpdatedAt time.Time `json:"updatedAt"`
}

// ManagedDomainStatus Whether the managed domain has completed the verification process.
type ManagedDomainStatus string

// NodePool defines model for NodePool.
type NodePool struct {
	// CloudProvider The name of the cloud provider.
	CloudProvider NodePoolCloudProvider `json:"cloudProvider"`

	// ClusterId The ID of the cluster that the node pool belongs to.
	ClusterId string `json:"clusterId"`

	// CreatedAt The time when the node pool was created in UTC, formatted as `YYYY-MM-DDTHH:MM:SSZ`.
	CreatedAt time.Time `json:"createdAt"`

	// Id The node pool's ID.
	Id string `json:"id"`

	// IsDefault Whether the node pool is the default node pool of the cluster.
	IsDefault bool `json:"isDefault"`

	// MaxNodeCount The maximum number of nodes that can be created in the node pool.
	MaxNodeCount int `json:"maxNodeCount"`

	// Name The name of the node pool.
	Name string `json:"name"`

	// NodeInstanceType The type of node instance that is used for the node pool.
	NodeInstanceType string `json:"nodeInstanceType"`

	// SupportedAstroMachines The list of supported Astro machines for the node pool. Returned only for Hosted dedicated clusters.
	SupportedAstroMachines *[]string `json:"supportedAstroMachines,omitempty"`

	// UpdatedAt The time when the node pool was last updated in UTC, formatted as `YYYY-MM-DDTHH:MM:SSZ`.
	UpdatedAt time.Time `json:"updatedAt"`
}

// NodePoolCloudProvider The name of the cloud provider.
type NodePoolCloudProvider string

// Organization defines model for Organization.
type Organization struct {
	// BillingEmail The Organization's billing email.
	BillingEmail *string `json:"billingEmail,omitempty"`

	// CreatedAt The time when the Organization was created in UTC, formatted as `YYYY-MM-DDTHH:MM:SSZ`.
	CreatedAt time.Time           `json:"createdAt"`
	CreatedBy BasicSubjectProfile `json:"createdBy"`

	// Id The Organization's ID.
	Id string `json:"id"`

	// IsScimEnabled Whether SCIM is enabled for the Organization.
	IsScimEnabled bool `json:"isScimEnabled"`

	// ManagedDomains The list of managed domains configured in the Organization.
	ManagedDomains *[]ManagedDomain `json:"managedDomains,omitempty"`

	// Name The Organization's name.
	Name string `json:"name"`

	// PaymentMethod The Organization's payment method.
	PaymentMethod *OrganizationPaymentMethod `json:"paymentMethod,omitempty"`

	// Product The Organization's product type.
	Product *OrganizationProduct `json:"product,omitempty"`

	// Status The Organization's status.
	Status *OrganizationStatus `json:"status,omitempty"`

	// SupportPlan The Organization's support plan.
	SupportPlan OrganizationSupportPlan `json:"supportPlan"`

	// TrialExpiresAt The time when the Organization's trial expires in UTC, formatted as `YYYY-MM-DDTHH:MM:SSZ`. Organizations that are no longer in Trial will not have a expiry date.
	TrialExpiresAt *time.Time `json:"trialExpiresAt,omitempty"`

	// UpdatedAt The time when the Organization was last updated in UTC, formatted as `YYYY-MM-DDTHH:MM:SSZ`.
	UpdatedAt time.Time           `json:"updatedAt"`
	UpdatedBy BasicSubjectProfile `json:"updatedBy"`
}

// OrganizationPaymentMethod The Organization's payment method.
type OrganizationPaymentMethod string

// OrganizationProduct The Organization's product type.
type OrganizationProduct string

// OrganizationStatus The Organization's status.
type OrganizationStatus string

// OrganizationSupportPlan The Organization's support plan.
type OrganizationSupportPlan string

// OrganizationsPaginated defines model for OrganizationsPaginated.
type OrganizationsPaginated struct {
	// Limit The maximum number of Organizations in the page.
	Limit int `json:"limit"`

	// Offset The offset of the Organizations in the page.
	Offset int `json:"offset"`

	// Organizations The list of Organizations in the page.
	Organizations []Organization `json:"organizations"`

	// TotalCount The total number of Organizations.
	TotalCount int `json:"totalCount"`
}

// ProviderInstanceType defines model for ProviderInstanceType.
type ProviderInstanceType struct {
	// Cpu The number of CPUs. Units are in number of CPU cores.
	Cpu int `json:"cpu"`

	// Memory The amount of memory. Units in Gibibytes or `Gi`.
	Memory string `json:"memory"`

	// Name The name of the instance type.
	Name string `json:"name"`
}

// ProviderRegion defines model for ProviderRegion.
type ProviderRegion struct {
	// BannedInstances The banned instances in the region.
	BannedInstances *[]string `json:"bannedInstances,omitempty"`

	// Limited Whether the region is limited.
	Limited *bool `json:"limited,omitempty"`

	// Name The name of the region.
	Name string `json:"name"`
}

// Range defines model for Range.
type Range struct {
	// Ceiling The maximum value.
	Ceiling float32 `json:"ceiling"`

	// Default The default value.
	Default float32 `json:"default"`

	// Floor The minimum value.
	Floor float32 `json:"floor"`
}

// ResourceOption defines model for ResourceOption.
type ResourceOption struct {
	Cpu    ResourceRange `json:"cpu"`
	Memory ResourceRange `json:"memory"`
}

// ResourceQuotaOptions defines model for ResourceQuotaOptions.
type ResourceQuotaOptions struct {
	DefaultPodSize ResourceOption `json:"defaultPodSize"`
	ResourceQuota  ResourceOption `json:"resourceQuota"`
}

// ResourceRange defines model for ResourceRange.
type ResourceRange struct {
	// Ceiling The maximum value.
	Ceiling string `json:"ceiling"`

	// Default The default value.
	Default string `json:"default"`

	// Floor The minimum value.
	Floor string `json:"floor"`
}

// RuntimeRelease defines model for RuntimeRelease.
type RuntimeRelease struct {
	// AirflowDatabaseMigration Whether the release requires an Airflow database migration.
	AirflowDatabaseMigration bool `json:"airflowDatabaseMigration"`

	// AirflowVersion The Airflow version that the Runtime image is based on.
	AirflowVersion string `json:"airflowVersion"`

	// Channel The release channel.
	Channel string `json:"channel"`

	// ReleaseDate The time when the version is released in UTC, formatted as `YYYY-MM-DDTHH:MM:SSZ`.
	ReleaseDate time.Time `json:"releaseDate"`

	// StellarDatabaseMigration Whether the release requires a Stellar database migration.
	StellarDatabaseMigration bool `json:"stellarDatabaseMigration"`

	// Version The Astro Runtime version.
	Version string `json:"version"`
}

// SchedulerMachine defines model for SchedulerMachine.
type SchedulerMachine struct {
	// Name The machine's name.
	Name SchedulerMachineName `json:"name"`
	Spec MachineSpec          `json:"spec"`
}

// SchedulerMachineName The machine's name.
type SchedulerMachineName string

// UpdateClusterRequest defines model for UpdateClusterRequest.
type UpdateClusterRequest struct {
	union json.RawMessage
}

// UpdateDedicatedClusterRequest defines model for UpdateDedicatedClusterRequest.
type UpdateDedicatedClusterRequest struct {
	// ClusterType The cluster's type.
	ClusterType *UpdateDedicatedClusterRequestClusterType `json:"clusterType,omitempty"`

	// DbInstanceType The cluster's database instance type. Required for Hybrid clusters.
	DbInstanceType *string `json:"dbInstanceType,omitempty"`

	// K8sTags A list of Kubernetes tags to add to the cluster.
	K8sTags []ClusterK8sTag `json:"k8sTags"`

	// Name The cluster's name.
	Name string `json:"name"`

	// NodePools A list of node pools to add to the cluster. For Hybrid clusters only.
	NodePools *[]UpdateNodePoolRequest `json:"nodePools,omitempty"`

	// WorkspaceIds The list of Workspaces that are authorized to the cluster. If this value is not provided, the existing list of Workspaces remains. If this value is '[]' then all workspace cluster mappings are removed.
	WorkspaceIds *[]string `json:"workspaceIds,omitempty"`
}

// UpdateDedicatedClusterRequestClusterType The cluster's type.
type UpdateDedicatedClusterRequestClusterType string

// UpdateDedicatedDeploymentRequest defines model for UpdateDedicatedDeploymentRequest.
type UpdateDedicatedDeploymentRequest struct {
	// ContactEmails A list of contact emails for the Deployment.
	ContactEmails *[]string `json:"contactEmails,omitempty"`

	// DefaultTaskPodCpu The default CPU resource usage for a worker Pod when running the Kubernetes executor or KubernetesPodOperator. Units are in number of CPU cores.
	DefaultTaskPodCpu string `json:"defaultTaskPodCpu"`

	// DefaultTaskPodMemory The default memory resource usage for a worker Pod when running the Kubernetes executor or KubernetesPodOperator. Units are in `Gi`. This value must always be twice the value of `DefaultTaskPodCpu`.
	DefaultTaskPodMemory string `json:"defaultTaskPodMemory"`

	// Description The Deployment's description.
	Description *string `json:"description,omitempty"`

	// EnvironmentVariables List of environment variables to add to the Deployment.
	EnvironmentVariables []DeploymentEnvironmentVariableRequest `json:"environmentVariables"`

	// Executor The executor Deployment's executor.
	Executor UpdateDedicatedDeploymentRequestExecutor `json:"executor"`

	// IsCicdEnforced Whether the Deployment requires that all deploys are made through CI/CD.
	IsCicdEnforced bool `json:"isCicdEnforced"`

	// IsDagDeployEnabled Whether the Deployment has DAG deploys enabled.
	IsDagDeployEnabled bool `json:"isDagDeployEnabled"`

	// IsHighAvailability Whether the Deployment is configured for high availability. If `true`, multiple scheduler pods will be online.
	IsHighAvailability bool `json:"isHighAvailability"`

	// Name The Deployment's name.
	Name string `json:"name"`

	// ResourceQuotaCpu The CPU quota for worker Pods when running the Kubernetes executor or KubernetesPodOperator. If current CPU usage across all workers exceeds the quota, no new worker Pods can be scheduled. Units are in number of CPU cores.
	ResourceQuotaCpu string `json:"resourceQuotaCpu"`

	// ResourceQuotaMemory The memory quota for worker Pods when running the Kubernetes executor or KubernetesPodOperator. If current memory usage across all workers exceeds the quota, no new worker Pods can be scheduled. Units are in `Gi`. This value must always be twice the value of `ResourceQuotaCpu`.
	ResourceQuotaMemory string `json:"resourceQuotaMemory"`

	// SchedulerSize The size of the scheduler pod.
	SchedulerSize UpdateDedicatedDeploymentRequestSchedulerSize `json:"schedulerSize"`

	// Type The type of the Deployment.
	Type UpdateDedicatedDeploymentRequestType `json:"type"`

	// WorkerQueues A list of the Deployment's worker queues. Applies only when `Executor` is `CELERY`. All Deployments need at least 1 worker queue called `default`.
	WorkerQueues *[]WorkerQueueRequest `json:"workerQueues,omitempty"`

	// WorkloadIdentity The Deployment's workload identity.
	WorkloadIdentity *string `json:"workloadIdentity,omitempty"`

	// WorkspaceId The ID of the Workspace to which the Deployment belongs.
	WorkspaceId string `json:"workspaceId"`
}

// UpdateDedicatedDeploymentRequestExecutor The executor Deployment's executor.
type UpdateDedicatedDeploymentRequestExecutor string

// UpdateDedicatedDeploymentRequestSchedulerSize The size of the scheduler pod.
type UpdateDedicatedDeploymentRequestSchedulerSize string

// UpdateDedicatedDeploymentRequestType The type of the Deployment.
type UpdateDedicatedDeploymentRequestType string

// UpdateDeploymentRequest defines model for UpdateDeploymentRequest.
type UpdateDeploymentRequest struct {
	union json.RawMessage
}

// UpdateHybridClusterRequest defines model for UpdateHybridClusterRequest.
type UpdateHybridClusterRequest struct {
	// ClusterType The cluster's type.
	ClusterType UpdateHybridClusterRequestClusterType `json:"clusterType"`

	// WorkspaceIds The list of Workspaces that are authorized to the cluster. If this value is not provided, the existing list of Workspaces remains. If this value is '[]' then all workspace cluster mappings are removed.
	WorkspaceIds *[]string `json:"workspaceIds,omitempty"`
}

// UpdateHybridClusterRequestClusterType The cluster's type.
type UpdateHybridClusterRequestClusterType string

// UpdateHybridDeploymentRequest defines model for UpdateHybridDeploymentRequest.
type UpdateHybridDeploymentRequest struct {
	// ContactEmails A list of contact emails for the Deployment.
	ContactEmails *[]string `json:"contactEmails,omitempty"`

	// Description The Deployment's description.
	Description *string `json:"description,omitempty"`

	// EnvironmentVariables List of environment variables to add to the Deployment.
	EnvironmentVariables []DeploymentEnvironmentVariableRequest `json:"environmentVariables"`

	// Executor The Deployment's executor type.
	Executor UpdateHybridDeploymentRequestExecutor `json:"executor"`

	// IsCicdEnforced Whether the Deployment requires that all deploys are made through CI/CD.
	IsCicdEnforced bool `json:"isCicdEnforced"`

	// IsDagDeployEnabled Whether the Deployment has DAG deploys enabled.
	IsDagDeployEnabled bool `json:"isDagDeployEnabled"`

	// Name The Deployment's name.
	Name      string                        `json:"name"`
	Scheduler DeploymentInstanceSpecRequest `json:"scheduler"`

	// TaskPodNodePoolId The node pool ID for worker Pods. Applies only when `Executor` is `KUBERNETES`.
	TaskPodNodePoolId *string `json:"taskPodNodePoolId,omitempty"`

	// Type The type of the Deployment.
	Type UpdateHybridDeploymentRequestType `json:"type"`

	// WorkerQueues The list of worker queues configured for the Deployment. Applies only when `Executor` is `CELERY`. All Deployments need at least 1 worker queue called `default`.
	WorkerQueues *[]HybridWorkerQueueRequest `json:"workerQueues,omitempty"`

	// WorkloadIdentity The Deployment's workload identity.
	WorkloadIdentity *string `json:"workloadIdentity,omitempty"`

	// WorkspaceId The ID of the Workspace to which the Deployment belongs.
	WorkspaceId string `json:"workspaceId"`
}

// UpdateHybridDeploymentRequestExecutor The Deployment's executor type.
type UpdateHybridDeploymentRequestExecutor string

// UpdateHybridDeploymentRequestType The type of the Deployment.
type UpdateHybridDeploymentRequestType string

// UpdateNodePoolRequest defines model for UpdateNodePoolRequest.
type UpdateNodePoolRequest struct {
	// Id The node pool's ID.
	Id *string `json:"id,omitempty"`

	// IsDefault Whether the node pool is the default node pool of the cluster.
	IsDefault *bool `json:"isDefault,omitempty"`

	// MaxNodeCount The maximum number of nodes that can be created in the node pool.
	MaxNodeCount int `json:"maxNodeCount"`

	// Name The name of the node pool.
	Name string `json:"name"`

	// NodeInstanceType The type of node instance that is used for the node pool.
	NodeInstanceType string `json:"nodeInstanceType"`
}

// UpdateOrganizationRequest defines model for UpdateOrganizationRequest.
type UpdateOrganizationRequest struct {
	// BillingEmail The Organization's billing email.
	BillingEmail string `json:"billingEmail"`

	// IsScimEnabled Whether SCIM is enabled for the Organization.
	IsScimEnabled bool `json:"isScimEnabled"`

	// Name The name of the Organization.
	Name string `json:"name"`
}

// UpdateStandardDeploymentRequest defines model for UpdateStandardDeploymentRequest.
type UpdateStandardDeploymentRequest struct {
	// ContactEmails A list of contact emails for the Deployment.
	ContactEmails *[]string `json:"contactEmails,omitempty"`

	// DefaultTaskPodCpu The default CPU resource usage for a worker Pod when running the Kubernetes executor or KubernetesPodOperator. Units are in number of CPU cores.
	DefaultTaskPodCpu string `json:"defaultTaskPodCpu"`

	// DefaultTaskPodMemory The default memory resource usage for a worker Pod when running the Kubernetes executor or KubernetesPodOperator. Units are in `Gi`. This value must always be twice the value of `DefaultTaskPodCpu`.
	DefaultTaskPodMemory string `json:"defaultTaskPodMemory"`

	// Description The Deployment's description.
	Description *string `json:"description,omitempty"`

	// EnvironmentVariables List of environment variables to add to the Deployment.
	EnvironmentVariables []DeploymentEnvironmentVariableRequest `json:"environmentVariables"`

	// Executor The executor Deployment's executor.
	Executor UpdateStandardDeploymentRequestExecutor `json:"executor"`

	// IsCicdEnforced Whether the Deployment requires that all deploys are made through CI/CD.
	IsCicdEnforced bool `json:"isCicdEnforced"`

	// IsDagDeployEnabled Whether the Deployment has DAG deploys enabled.
	IsDagDeployEnabled bool `json:"isDagDeployEnabled"`

	// IsHighAvailability Whether the Deployment is configured for high availability. If `true`, multiple scheduler pods will be online.
	IsHighAvailability bool `json:"isHighAvailability"`

	// Name The Deployment's name.
	Name string `json:"name"`

	// ResourceQuotaCpu The CPU quota for worker Pods when running the Kubernetes executor or KubernetesPodOperator. If current CPU usage across all workers exceeds the quota, no new worker Pods can be scheduled. Units are in number of CPU cores.
	ResourceQuotaCpu string `json:"resourceQuotaCpu"`

	// ResourceQuotaMemory The memory quota for worker Pods when running the Kubernetes executor or KubernetesPodOperator. If current memory usage across all workers exceeds the quota, no new worker Pods can be scheduled. Units are in `Gi`. This value must always be twice the value of `ResourceQuotaCpu`.
	ResourceQuotaMemory string `json:"resourceQuotaMemory"`

	// SchedulerSize The size of the scheduler pod.
	SchedulerSize UpdateStandardDeploymentRequestSchedulerSize `json:"schedulerSize"`

	// Type The type of the Deployment.
	Type UpdateStandardDeploymentRequestType `json:"type"`

	// WorkerQueues A list of the Deployment's worker queues. Applies only when `Executor` is `CELERY`. All Deployments need at least 1 worker queue called `default`.
	WorkerQueues *[]WorkerQueueRequest `json:"workerQueues,omitempty"`

	// WorkloadIdentity The Deployment's workload identity.
	WorkloadIdentity *string `json:"workloadIdentity,omitempty"`

	// WorkspaceId The ID of the Workspace to which the Deployment belongs.
	WorkspaceId string `json:"workspaceId"`
}

// UpdateStandardDeploymentRequestExecutor The executor Deployment's executor.
type UpdateStandardDeploymentRequestExecutor string

// UpdateStandardDeploymentRequestSchedulerSize The size of the scheduler pod.
type UpdateStandardDeploymentRequestSchedulerSize string

// UpdateStandardDeploymentRequestType The type of the Deployment.
type UpdateStandardDeploymentRequestType string

// UpdateWorkspaceRequest defines model for UpdateWorkspaceRequest.
type UpdateWorkspaceRequest struct {
	// CicdEnforcedDefault Whether new Deployments enforce CI/CD deploys by default.
	CicdEnforcedDefault bool `json:"cicdEnforcedDefault"`

	// Description The Workspace's description.
	Description string `json:"description"`

	// Name The Workspace's name.
	Name string `json:"name"`
}

// WorkerMachine defines model for WorkerMachine.
type WorkerMachine struct {
	Concurrency Range `json:"concurrency"`

	// Name The machine's name.
	Name WorkerMachineName `json:"name"`
	Spec MachineSpec       `json:"spec"`
}

// WorkerMachineName The machine's name.
type WorkerMachineName string

// WorkerQueue defines model for WorkerQueue.
type WorkerQueue struct {
	// AstroMachine The Astro machine size for each worker node in the queue. For Astro Hosted only.
	AstroMachine *string `json:"astroMachine,omitempty"`

	// Id The worker queue's ID.
	Id string `json:"id"`

	// IsDefault Whether the worker queue is the default worker queue in the Deployment.
	IsDefault bool `json:"isDefault"`

	// MaxWorkerCount The maximum number of workers that can run at once.
	MaxWorkerCount int `json:"maxWorkerCount"`

	// MinWorkerCount The minimum number of workers running at once.
	MinWorkerCount int `json:"minWorkerCount"`

	// Name The worker queue's name.
	Name string `json:"name"`

	// NodePoolId The node pool ID associated with the worker queue.
	NodePoolId *string `json:"nodePoolId,omitempty"`

	// PodCpu The maximum number of CPU units available for a worker node. Units are in number of CPU cores.
	PodCpu string `json:"podCpu"`

	// PodMemory The maximum amount of memory available for a worker node. Units are in Gibibytes or `Gi`.
	PodMemory string `json:"podMemory"`

	// WorkerConcurrency The maximum number of concurrent tasks that a worker Pod can run at a time.
	WorkerConcurrency int `json:"workerConcurrency"`
}

// WorkerQueueOptions defines model for WorkerQueueOptions.
type WorkerQueueOptions struct {
	MaxWorkers        Range `json:"maxWorkers"`
	MinWorkers        Range `json:"minWorkers"`
	WorkerConcurrency Range `json:"workerConcurrency"`
}

// WorkerQueueRequest defines model for WorkerQueueRequest.
type WorkerQueueRequest struct {
	// AstroMachine The Astro machine for each worker in the queue. For Astro Hosted only.
	AstroMachine WorkerQueueRequestAstroMachine `json:"astroMachine"`

	// Id The worker queue's ID. If not provided, a new worker queue will be created.
	Id *string `json:"id,omitempty"`

	// IsDefault Whether the worker queue is the default worker queue on the Deployment.
	IsDefault bool `json:"isDefault"`

	// MaxWorkerCount The maximum number of workers that can run at once.
	MaxWorkerCount int `json:"maxWorkerCount"`

	// MinWorkerCount The minimum number of workers running at once.
	MinWorkerCount int `json:"minWorkerCount"`

	// Name The worker queue's name.
	Name string `json:"name"`

	// WorkerConcurrency The maximum number of concurrent tasks that a worker Pod can run at a time.
	WorkerConcurrency int `json:"workerConcurrency"`
}

// WorkerQueueRequestAstroMachine The Astro machine for each worker in the queue. For Astro Hosted only.
type WorkerQueueRequestAstroMachine string

// WorkloadIdentityOption defines model for WorkloadIdentityOption.
type WorkloadIdentityOption struct {
	// Label The workload identity label.
	Label string `json:"label"`

	// Role The workload identity role.
	Role string `json:"role"`
}

// Workspace defines model for Workspace.
type Workspace struct {
	// CicdEnforcedDefault Whether CI/CD deploys are enforced by default.
	CicdEnforcedDefault bool `json:"cicdEnforcedDefault"`

	// CreatedAt The time when the Workspace was created in UTC, formatted as `YYYY-MM-DDTHH:MM:SSZ`
	CreatedAt time.Time            `json:"createdAt"`
	CreatedBy *BasicSubjectProfile `json:"createdBy,omitempty"`

	// Description The Workspace's description.
	Description *string `json:"description,omitempty"`

	// Id The Workspace's ID.
	Id string `json:"id"`

	// Name The Workspace's name.
	Name string `json:"name"`

	// OrganizationId The ID of the organization to which the workspace belongs.
	OrganizationId string `json:"organizationId"`

	// OrganizationName The name of the Organization to which the Workspace belongs.
	OrganizationName *string `json:"organizationName,omitempty"`

	// UpdatedAt The time when the Workspace was updated in UTC, formatted as `YYYY-MM-DDTHH:MM:SSZ`
	UpdatedAt time.Time            `json:"updatedAt"`
	UpdatedBy *BasicSubjectProfile `json:"updatedBy,omitempty"`
}

// WorkspacesPaginated defines model for WorkspacesPaginated.
type WorkspacesPaginated struct {
	// Limit The maximum number of workspaces that can be retrieved per page.
	Limit int `json:"limit"`

	// Offset The offset for the current page of workspaces in the complete result.
	Offset int `json:"offset"`

	// TotalCount The total number of Workspaces in the paginated result.
	TotalCount int `json:"totalCount"`

	// Workspaces An array of Workspace objects representing a list of workspaces.
	Workspaces []Workspace `json:"workspaces"`
}

// ListOrganizationsParams defines parameters for ListOrganizations.
type ListOrganizationsParams struct {
	// SupportPlan Filters the Organization list by support plan.
	SupportPlan *ListOrganizationsParamsSupportPlan `form:"supportPlan,omitempty" json:"supportPlan,omitempty"`

	// Product Filters the Organization list by product.
	Product *ListOrganizationsParamsProduct `form:"product,omitempty" json:"product,omitempty"`

	// Offset The number of results to skip before returning values.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The maximum number of results to return.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sorts A list of field names to sort by, and whether to show results as ascending or descending. Formatted as `<fieldName>:asc` or `<fieldName>:desc`.
	Sorts *[]ListOrganizationsParamsSorts `form:"sorts,omitempty" json:"sorts,omitempty"`
}

// ListOrganizationsParamsSupportPlan defines parameters for ListOrganizations.
type ListOrganizationsParamsSupportPlan string

// ListOrganizationsParamsProduct defines parameters for ListOrganizations.
type ListOrganizationsParamsProduct string

// ListOrganizationsParamsSorts defines parameters for ListOrganizations.
type ListOrganizationsParamsSorts string

// GetOrganizationParams defines parameters for GetOrganization.
type GetOrganizationParams struct {
	// IsLookUpOnly Whether to show only Organization metadata.
	IsLookUpOnly *bool `form:"isLookUpOnly,omitempty" json:"isLookUpOnly,omitempty"`
}

// GetClusterOptionsParams defines parameters for GetClusterOptions.
type GetClusterOptionsParams struct {
	// Provider The cluster's cloud provider.
	Provider *GetClusterOptionsParamsProvider `form:"provider,omitempty" json:"provider,omitempty"`

	// Type The cluster type.
	Type GetClusterOptionsParamsType `form:"type" json:"type"`
}

// GetClusterOptionsParamsProvider defines parameters for GetClusterOptions.
type GetClusterOptionsParamsProvider string

// GetClusterOptionsParamsType defines parameters for GetClusterOptions.
type GetClusterOptionsParamsType string

// ListClustersParams defines parameters for ListClusters.
type ListClustersParams struct {
	// Provider The cloud provider to list clusters for. Clusters from other providers will be filtered out of the results.
	Provider *ListClustersParamsProvider `form:"provider,omitempty" json:"provider,omitempty"`

	// Offset The number of results to skip before returning values.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The maximum number of results to return.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sorts A list of field names to sort by, and whether to show results as ascending or descending. Formatted as `<fieldName>:asc` or `<fieldName>:desc`.
	Sorts *[]ListClustersParamsSorts `form:"sorts,omitempty" json:"sorts,omitempty"`
}

// ListClustersParamsProvider defines parameters for ListClusters.
type ListClustersParamsProvider string

// ListClustersParamsSorts defines parameters for ListClusters.
type ListClustersParamsSorts string

// GetDeploymentOptionsParams defines parameters for GetDeploymentOptions.
type GetDeploymentOptionsParams struct {
	// DeploymentId The ID of a Deployment to retrieve options for.
	DeploymentId *string `form:"deploymentId,omitempty" json:"deploymentId,omitempty"`

	// DeploymentType The runtime type of the deployment.
	DeploymentType *GetDeploymentOptionsParamsDeploymentType `form:"deploymentType,omitempty" json:"deploymentType,omitempty"`

	// Executor The executor of the deployment.
	Executor *GetDeploymentOptionsParamsExecutor `form:"executor,omitempty" json:"executor,omitempty"`

	// CloudProvider The cloud provider of the cluster for the deployment.
	CloudProvider *GetDeploymentOptionsParamsCloudProvider `form:"cloudProvider,omitempty" json:"cloudProvider,omitempty"`
}

// GetDeploymentOptionsParamsDeploymentType defines parameters for GetDeploymentOptions.
type GetDeploymentOptionsParamsDeploymentType string

// GetDeploymentOptionsParamsExecutor defines parameters for GetDeploymentOptions.
type GetDeploymentOptionsParamsExecutor string

// GetDeploymentOptionsParamsCloudProvider defines parameters for GetDeploymentOptions.
type GetDeploymentOptionsParamsCloudProvider string

// ListDeploymentsParams defines parameters for ListDeployments.
type ListDeploymentsParams struct {
	// DeploymentIds A list of IDs for Deployments to show. The API returns details only for the specified Deployments.
	DeploymentIds *[]string `form:"deploymentIds,omitempty" json:"deploymentIds,omitempty"`

	// WorkspaceIds A list of IDs for Workspaces to filter on. The API returns details for all Deployments belonging only to the specified Workspaces.
	WorkspaceIds *[]string `form:"workspaceIds,omitempty" json:"workspaceIds,omitempty"`

	// Offset The number of results to skip before returning values.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The maximum number of results to return.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sorts A list of field names to sort by, and whether to show results as ascending or descending. Formatted as `<fieldName>:asc` or `<fieldName>:desc`.
	Sorts *[]ListDeploymentsParamsSorts `form:"sorts,omitempty" json:"sorts,omitempty"`
}

// ListDeploymentsParamsSorts defines parameters for ListDeployments.
type ListDeploymentsParamsSorts string

// ListWorkspacesParams defines parameters for ListWorkspaces.
type ListWorkspacesParams struct {
	// WorkspaceIds A list of IDs for specific Workspaces to list. The API will list information only for Workspaces which have been specified in this list.
	WorkspaceIds *[]string `form:"workspaceIds,omitempty" json:"workspaceIds,omitempty"`

	// Offset The number of results to skip before returning values.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The maximum number of results to return.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sorts A list of field names to sort by, and whether to show results as ascending or descending. Formatted as `<fieldName>:asc` or `<fieldName>:desc`.
	Sorts *[]ListWorkspacesParamsSorts `form:"sorts,omitempty" json:"sorts,omitempty"`
}

// ListWorkspacesParamsSorts defines parameters for ListWorkspaces.
type ListWorkspacesParamsSorts string

// UpdateOrganizationJSONRequestBody defines body for UpdateOrganization for application/json ContentType.
type UpdateOrganizationJSONRequestBody = UpdateOrganizationRequest

// CreateClusterJSONRequestBody defines body for CreateCluster for application/json ContentType.
type CreateClusterJSONRequestBody = CreateClusterRequest

// UpdateClusterJSONRequestBody defines body for UpdateCluster for application/json ContentType.
type UpdateClusterJSONRequestBody = UpdateClusterRequest

// CreateDeploymentJSONRequestBody defines body for CreateDeployment for application/json ContentType.
type CreateDeploymentJSONRequestBody = CreateDeploymentRequest

// UpdateDeploymentJSONRequestBody defines body for UpdateDeployment for application/json ContentType.
type UpdateDeploymentJSONRequestBody = UpdateDeploymentRequest

// CreateWorkspaceJSONRequestBody defines body for CreateWorkspace for application/json ContentType.
type CreateWorkspaceJSONRequestBody = CreateWorkspaceRequest

// UpdateWorkspaceJSONRequestBody defines body for UpdateWorkspace for application/json ContentType.
type UpdateWorkspaceJSONRequestBody = UpdateWorkspaceRequest

// AsCreateAwsClusterRequest returns the union data inside the CreateClusterRequest as a CreateAwsClusterRequest
func (t CreateClusterRequest) AsCreateAwsClusterRequest() (CreateAwsClusterRequest, error) {
	var body CreateAwsClusterRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateAwsClusterRequest overwrites any union data inside the CreateClusterRequest as the provided CreateAwsClusterRequest
func (t *CreateClusterRequest) FromCreateAwsClusterRequest(v CreateAwsClusterRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateAwsClusterRequest performs a merge with any union data inside the CreateClusterRequest, using the provided CreateAwsClusterRequest
func (t *CreateClusterRequest) MergeCreateAwsClusterRequest(v CreateAwsClusterRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsCreateAzureClusterRequest returns the union data inside the CreateClusterRequest as a CreateAzureClusterRequest
func (t CreateClusterRequest) AsCreateAzureClusterRequest() (CreateAzureClusterRequest, error) {
	var body CreateAzureClusterRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateAzureClusterRequest overwrites any union data inside the CreateClusterRequest as the provided CreateAzureClusterRequest
func (t *CreateClusterRequest) FromCreateAzureClusterRequest(v CreateAzureClusterRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateAzureClusterRequest performs a merge with any union data inside the CreateClusterRequest, using the provided CreateAzureClusterRequest
func (t *CreateClusterRequest) MergeCreateAzureClusterRequest(v CreateAzureClusterRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsCreateGcpClusterRequest returns the union data inside the CreateClusterRequest as a CreateGcpClusterRequest
func (t CreateClusterRequest) AsCreateGcpClusterRequest() (CreateGcpClusterRequest, error) {
	var body CreateGcpClusterRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateGcpClusterRequest overwrites any union data inside the CreateClusterRequest as the provided CreateGcpClusterRequest
func (t *CreateClusterRequest) FromCreateGcpClusterRequest(v CreateGcpClusterRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateGcpClusterRequest performs a merge with any union data inside the CreateClusterRequest, using the provided CreateGcpClusterRequest
func (t *CreateClusterRequest) MergeCreateGcpClusterRequest(v CreateGcpClusterRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t CreateClusterRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateClusterRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateDedicatedDeploymentRequest returns the union data inside the CreateDeploymentRequest as a CreateDedicatedDeploymentRequest
func (t CreateDeploymentRequest) AsCreateDedicatedDeploymentRequest() (CreateDedicatedDeploymentRequest, error) {
	var body CreateDedicatedDeploymentRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateDedicatedDeploymentRequest overwrites any union data inside the CreateDeploymentRequest as the provided CreateDedicatedDeploymentRequest
func (t *CreateDeploymentRequest) FromCreateDedicatedDeploymentRequest(v CreateDedicatedDeploymentRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateDedicatedDeploymentRequest performs a merge with any union data inside the CreateDeploymentRequest, using the provided CreateDedicatedDeploymentRequest
func (t *CreateDeploymentRequest) MergeCreateDedicatedDeploymentRequest(v CreateDedicatedDeploymentRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsCreateHybridDeploymentRequest returns the union data inside the CreateDeploymentRequest as a CreateHybridDeploymentRequest
func (t CreateDeploymentRequest) AsCreateHybridDeploymentRequest() (CreateHybridDeploymentRequest, error) {
	var body CreateHybridDeploymentRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateHybridDeploymentRequest overwrites any union data inside the CreateDeploymentRequest as the provided CreateHybridDeploymentRequest
func (t *CreateDeploymentRequest) FromCreateHybridDeploymentRequest(v CreateHybridDeploymentRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateHybridDeploymentRequest performs a merge with any union data inside the CreateDeploymentRequest, using the provided CreateHybridDeploymentRequest
func (t *CreateDeploymentRequest) MergeCreateHybridDeploymentRequest(v CreateHybridDeploymentRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsCreateStandardDeploymentRequest returns the union data inside the CreateDeploymentRequest as a CreateStandardDeploymentRequest
func (t CreateDeploymentRequest) AsCreateStandardDeploymentRequest() (CreateStandardDeploymentRequest, error) {
	var body CreateStandardDeploymentRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateStandardDeploymentRequest overwrites any union data inside the CreateDeploymentRequest as the provided CreateStandardDeploymentRequest
func (t *CreateDeploymentRequest) FromCreateStandardDeploymentRequest(v CreateStandardDeploymentRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateStandardDeploymentRequest performs a merge with any union data inside the CreateDeploymentRequest, using the provided CreateStandardDeploymentRequest
func (t *CreateDeploymentRequest) MergeCreateStandardDeploymentRequest(v CreateStandardDeploymentRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t CreateDeploymentRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateDeploymentRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUpdateDedicatedClusterRequest returns the union data inside the UpdateClusterRequest as a UpdateDedicatedClusterRequest
func (t UpdateClusterRequest) AsUpdateDedicatedClusterRequest() (UpdateDedicatedClusterRequest, error) {
	var body UpdateDedicatedClusterRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateDedicatedClusterRequest overwrites any union data inside the UpdateClusterRequest as the provided UpdateDedicatedClusterRequest
func (t *UpdateClusterRequest) FromUpdateDedicatedClusterRequest(v UpdateDedicatedClusterRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateDedicatedClusterRequest performs a merge with any union data inside the UpdateClusterRequest, using the provided UpdateDedicatedClusterRequest
func (t *UpdateClusterRequest) MergeUpdateDedicatedClusterRequest(v UpdateDedicatedClusterRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsUpdateHybridClusterRequest returns the union data inside the UpdateClusterRequest as a UpdateHybridClusterRequest
func (t UpdateClusterRequest) AsUpdateHybridClusterRequest() (UpdateHybridClusterRequest, error) {
	var body UpdateHybridClusterRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateHybridClusterRequest overwrites any union data inside the UpdateClusterRequest as the provided UpdateHybridClusterRequest
func (t *UpdateClusterRequest) FromUpdateHybridClusterRequest(v UpdateHybridClusterRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateHybridClusterRequest performs a merge with any union data inside the UpdateClusterRequest, using the provided UpdateHybridClusterRequest
func (t *UpdateClusterRequest) MergeUpdateHybridClusterRequest(v UpdateHybridClusterRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t UpdateClusterRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdateClusterRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUpdateDedicatedDeploymentRequest returns the union data inside the UpdateDeploymentRequest as a UpdateDedicatedDeploymentRequest
func (t UpdateDeploymentRequest) AsUpdateDedicatedDeploymentRequest() (UpdateDedicatedDeploymentRequest, error) {
	var body UpdateDedicatedDeploymentRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateDedicatedDeploymentRequest overwrites any union data inside the UpdateDeploymentRequest as the provided UpdateDedicatedDeploymentRequest
func (t *UpdateDeploymentRequest) FromUpdateDedicatedDeploymentRequest(v UpdateDedicatedDeploymentRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateDedicatedDeploymentRequest performs a merge with any union data inside the UpdateDeploymentRequest, using the provided UpdateDedicatedDeploymentRequest
func (t *UpdateDeploymentRequest) MergeUpdateDedicatedDeploymentRequest(v UpdateDedicatedDeploymentRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsUpdateHybridDeploymentRequest returns the union data inside the UpdateDeploymentRequest as a UpdateHybridDeploymentRequest
func (t UpdateDeploymentRequest) AsUpdateHybridDeploymentRequest() (UpdateHybridDeploymentRequest, error) {
	var body UpdateHybridDeploymentRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateHybridDeploymentRequest overwrites any union data inside the UpdateDeploymentRequest as the provided UpdateHybridDeploymentRequest
func (t *UpdateDeploymentRequest) FromUpdateHybridDeploymentRequest(v UpdateHybridDeploymentRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateHybridDeploymentRequest performs a merge with any union data inside the UpdateDeploymentRequest, using the provided UpdateHybridDeploymentRequest
func (t *UpdateDeploymentRequest) MergeUpdateHybridDeploymentRequest(v UpdateHybridDeploymentRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsUpdateStandardDeploymentRequest returns the union data inside the UpdateDeploymentRequest as a UpdateStandardDeploymentRequest
func (t UpdateDeploymentRequest) AsUpdateStandardDeploymentRequest() (UpdateStandardDeploymentRequest, error) {
	var body UpdateStandardDeploymentRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateStandardDeploymentRequest overwrites any union data inside the UpdateDeploymentRequest as the provided UpdateStandardDeploymentRequest
func (t *UpdateDeploymentRequest) FromUpdateStandardDeploymentRequest(v UpdateStandardDeploymentRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateStandardDeploymentRequest performs a merge with any union data inside the UpdateDeploymentRequest, using the provided UpdateStandardDeploymentRequest
func (t *UpdateDeploymentRequest) MergeUpdateStandardDeploymentRequest(v UpdateStandardDeploymentRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t UpdateDeploymentRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdateDeploymentRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListOrganizations request
	ListOrganizations(ctx context.Context, params *ListOrganizationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrganization request
	GetOrganization(ctx context.Context, organizationId string, params *GetOrganizationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateOrganization request with any body
	UpdateOrganizationWithBody(ctx context.Context, organizationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateOrganization(ctx context.Context, organizationId string, body UpdateOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClusterOptions request
	GetClusterOptions(ctx context.Context, organizationId string, params *GetClusterOptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListClusters request
	ListClusters(ctx context.Context, organizationId string, params *ListClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCluster request with any body
	CreateClusterWithBody(ctx context.Context, organizationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCluster(ctx context.Context, organizationId string, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCluster request
	DeleteCluster(ctx context.Context, organizationId string, clusterId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCluster request
	GetCluster(ctx context.Context, organizationId string, clusterId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCluster request with any body
	UpdateClusterWithBody(ctx context.Context, organizationId string, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCluster(ctx context.Context, organizationId string, clusterId string, body UpdateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDeploymentOptions request
	GetDeploymentOptions(ctx context.Context, organizationId string, params *GetDeploymentOptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDeployments request
	ListDeployments(ctx context.Context, organizationId string, params *ListDeploymentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDeployment request with any body
	CreateDeploymentWithBody(ctx context.Context, organizationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDeployment(ctx context.Context, organizationId string, body CreateDeploymentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDeployment request
	DeleteDeployment(ctx context.Context, organizationId string, deploymentId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDeployment request
	GetDeployment(ctx context.Context, organizationId string, deploymentId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDeployment request with any body
	UpdateDeploymentWithBody(ctx context.Context, organizationId string, deploymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDeployment(ctx context.Context, organizationId string, deploymentId string, body UpdateDeploymentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWorkspaces request
	ListWorkspaces(ctx context.Context, organizationId string, params *ListWorkspacesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateWorkspace request with any body
	CreateWorkspaceWithBody(ctx context.Context, organizationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateWorkspace(ctx context.Context, organizationId string, body CreateWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWorkspace request
	DeleteWorkspace(ctx context.Context, organizationId string, workspaceId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWorkspace request
	GetWorkspace(ctx context.Context, organizationId string, workspaceId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateWorkspace request with any body
	UpdateWorkspaceWithBody(ctx context.Context, organizationId string, workspaceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateWorkspace(ctx context.Context, organizationId string, workspaceId string, body UpdateWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListOrganizations(ctx context.Context, params *ListOrganizationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListOrganizationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrganization(ctx context.Context, organizationId string, params *GetOrganizationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrganizationRequest(c.Server, organizationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOrganizationWithBody(ctx context.Context, organizationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOrganizationRequestWithBody(c.Server, organizationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOrganization(ctx context.Context, organizationId string, body UpdateOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOrganizationRequest(c.Server, organizationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClusterOptions(ctx context.Context, organizationId string, params *GetClusterOptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClusterOptionsRequest(c.Server, organizationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListClusters(ctx context.Context, organizationId string, params *ListClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListClustersRequest(c.Server, organizationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClusterWithBody(ctx context.Context, organizationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClusterRequestWithBody(c.Server, organizationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCluster(ctx context.Context, organizationId string, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClusterRequest(c.Server, organizationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCluster(ctx context.Context, organizationId string, clusterId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteClusterRequest(c.Server, organizationId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCluster(ctx context.Context, organizationId string, clusterId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClusterRequest(c.Server, organizationId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateClusterWithBody(ctx context.Context, organizationId string, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClusterRequestWithBody(c.Server, organizationId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCluster(ctx context.Context, organizationId string, clusterId string, body UpdateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClusterRequest(c.Server, organizationId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDeploymentOptions(ctx context.Context, organizationId string, params *GetDeploymentOptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDeploymentOptionsRequest(c.Server, organizationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDeployments(ctx context.Context, organizationId string, params *ListDeploymentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDeploymentsRequest(c.Server, organizationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDeploymentWithBody(ctx context.Context, organizationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDeploymentRequestWithBody(c.Server, organizationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDeployment(ctx context.Context, organizationId string, body CreateDeploymentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDeploymentRequest(c.Server, organizationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDeployment(ctx context.Context, organizationId string, deploymentId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDeploymentRequest(c.Server, organizationId, deploymentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDeployment(ctx context.Context, organizationId string, deploymentId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDeploymentRequest(c.Server, organizationId, deploymentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDeploymentWithBody(ctx context.Context, organizationId string, deploymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDeploymentRequestWithBody(c.Server, organizationId, deploymentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDeployment(ctx context.Context, organizationId string, deploymentId string, body UpdateDeploymentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDeploymentRequest(c.Server, organizationId, deploymentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWorkspaces(ctx context.Context, organizationId string, params *ListWorkspacesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWorkspacesRequest(c.Server, organizationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWorkspaceWithBody(ctx context.Context, organizationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWorkspaceRequestWithBody(c.Server, organizationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWorkspace(ctx context.Context, organizationId string, body CreateWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWorkspaceRequest(c.Server, organizationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWorkspace(ctx context.Context, organizationId string, workspaceId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWorkspaceRequest(c.Server, organizationId, workspaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWorkspace(ctx context.Context, organizationId string, workspaceId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWorkspaceRequest(c.Server, organizationId, workspaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWorkspaceWithBody(ctx context.Context, organizationId string, workspaceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWorkspaceRequestWithBody(c.Server, organizationId, workspaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWorkspace(ctx context.Context, organizationId string, workspaceId string, body UpdateWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWorkspaceRequest(c.Server, organizationId, workspaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListOrganizationsRequest generates requests for ListOrganizations
func NewListOrganizationsRequest(server string, params *ListOrganizationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.SupportPlan != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "supportPlan", runtime.ParamLocationQuery, *params.SupportPlan); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Product != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product", runtime.ParamLocationQuery, *params.Product); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sorts != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sorts", runtime.ParamLocationQuery, *params.Sorts); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrganizationRequest generates requests for GetOrganization
func NewGetOrganizationRequest(server string, organizationId string, params *GetOrganizationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsLookUpOnly != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isLookUpOnly", runtime.ParamLocationQuery, *params.IsLookUpOnly); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOrganizationRequest calls the generic UpdateOrganization builder with application/json body
func NewUpdateOrganizationRequest(server string, organizationId string, body UpdateOrganizationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOrganizationRequestWithBody(server, organizationId, "application/json", bodyReader)
}

// NewUpdateOrganizationRequestWithBody generates requests for UpdateOrganization with any type of body
func NewUpdateOrganizationRequestWithBody(server string, organizationId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetClusterOptionsRequest generates requests for GetClusterOptions
func NewGetClusterOptionsRequest(server string, organizationId string, params *GetClusterOptionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/cluster-options", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Provider != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "provider", runtime.ParamLocationQuery, *params.Provider); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, params.Type); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListClustersRequest generates requests for ListClusters
func NewListClustersRequest(server string, organizationId string, params *ListClustersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/clusters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Provider != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "provider", runtime.ParamLocationQuery, *params.Provider); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sorts != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sorts", runtime.ParamLocationQuery, *params.Sorts); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateClusterRequest calls the generic CreateCluster builder with application/json body
func NewCreateClusterRequest(server string, organizationId string, body CreateClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateClusterRequestWithBody(server, organizationId, "application/json", bodyReader)
}

// NewCreateClusterRequestWithBody generates requests for CreateCluster with any type of body
func NewCreateClusterRequestWithBody(server string, organizationId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/clusters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteClusterRequest generates requests for DeleteCluster
func NewDeleteClusterRequest(server string, organizationId string, clusterId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/clusters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClusterRequest generates requests for GetCluster
func NewGetClusterRequest(server string, organizationId string, clusterId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/clusters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateClusterRequest calls the generic UpdateCluster builder with application/json body
func NewUpdateClusterRequest(server string, organizationId string, clusterId string, body UpdateClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateClusterRequestWithBody(server, organizationId, clusterId, "application/json", bodyReader)
}

// NewUpdateClusterRequestWithBody generates requests for UpdateCluster with any type of body
func NewUpdateClusterRequestWithBody(server string, organizationId string, clusterId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/clusters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDeploymentOptionsRequest generates requests for GetDeploymentOptions
func NewGetDeploymentOptionsRequest(server string, organizationId string, params *GetDeploymentOptionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/deployment-options", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.DeploymentId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deploymentId", runtime.ParamLocationQuery, *params.DeploymentId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.DeploymentType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deploymentType", runtime.ParamLocationQuery, *params.DeploymentType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Executor != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "executor", runtime.ParamLocationQuery, *params.Executor); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.CloudProvider != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cloudProvider", runtime.ParamLocationQuery, *params.CloudProvider); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListDeploymentsRequest generates requests for ListDeployments
func NewListDeploymentsRequest(server string, organizationId string, params *ListDeploymentsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/deployments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.DeploymentIds != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deploymentIds", runtime.ParamLocationQuery, *params.DeploymentIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.WorkspaceIds != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "workspaceIds", runtime.ParamLocationQuery, *params.WorkspaceIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sorts != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sorts", runtime.ParamLocationQuery, *params.Sorts); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDeploymentRequest calls the generic CreateDeployment builder with application/json body
func NewCreateDeploymentRequest(server string, organizationId string, body CreateDeploymentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDeploymentRequestWithBody(server, organizationId, "application/json", bodyReader)
}

// NewCreateDeploymentRequestWithBody generates requests for CreateDeployment with any type of body
func NewCreateDeploymentRequestWithBody(server string, organizationId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/deployments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDeploymentRequest generates requests for DeleteDeployment
func NewDeleteDeploymentRequest(server string, organizationId string, deploymentId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "deploymentId", runtime.ParamLocationPath, deploymentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/deployments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDeploymentRequest generates requests for GetDeployment
func NewGetDeploymentRequest(server string, organizationId string, deploymentId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "deploymentId", runtime.ParamLocationPath, deploymentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/deployments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDeploymentRequest calls the generic UpdateDeployment builder with application/json body
func NewUpdateDeploymentRequest(server string, organizationId string, deploymentId string, body UpdateDeploymentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDeploymentRequestWithBody(server, organizationId, deploymentId, "application/json", bodyReader)
}

// NewUpdateDeploymentRequestWithBody generates requests for UpdateDeployment with any type of body
func NewUpdateDeploymentRequestWithBody(server string, organizationId string, deploymentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "deploymentId", runtime.ParamLocationPath, deploymentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/deployments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListWorkspacesRequest generates requests for ListWorkspaces
func NewListWorkspacesRequest(server string, organizationId string, params *ListWorkspacesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/workspaces", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.WorkspaceIds != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "workspaceIds", runtime.ParamLocationQuery, *params.WorkspaceIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sorts != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sorts", runtime.ParamLocationQuery, *params.Sorts); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateWorkspaceRequest calls the generic CreateWorkspace builder with application/json body
func NewCreateWorkspaceRequest(server string, organizationId string, body CreateWorkspaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateWorkspaceRequestWithBody(server, organizationId, "application/json", bodyReader)
}

// NewCreateWorkspaceRequestWithBody generates requests for CreateWorkspace with any type of body
func NewCreateWorkspaceRequestWithBody(server string, organizationId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/workspaces", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteWorkspaceRequest generates requests for DeleteWorkspace
func NewDeleteWorkspaceRequest(server string, organizationId string, workspaceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspaceId", runtime.ParamLocationPath, workspaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/workspaces/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWorkspaceRequest generates requests for GetWorkspace
func NewGetWorkspaceRequest(server string, organizationId string, workspaceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspaceId", runtime.ParamLocationPath, workspaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/workspaces/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateWorkspaceRequest calls the generic UpdateWorkspace builder with application/json body
func NewUpdateWorkspaceRequest(server string, organizationId string, workspaceId string, body UpdateWorkspaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateWorkspaceRequestWithBody(server, organizationId, workspaceId, "application/json", bodyReader)
}

// NewUpdateWorkspaceRequestWithBody generates requests for UpdateWorkspace with any type of body
func NewUpdateWorkspaceRequestWithBody(server string, organizationId string, workspaceId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspaceId", runtime.ParamLocationPath, workspaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/workspaces/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListOrganizations request
	ListOrganizationsWithResponse(ctx context.Context, params *ListOrganizationsParams, reqEditors ...RequestEditorFn) (*ListOrganizationsResponse, error)

	// GetOrganization request
	GetOrganizationWithResponse(ctx context.Context, organizationId string, params *GetOrganizationParams, reqEditors ...RequestEditorFn) (*GetOrganizationResponse, error)

	// UpdateOrganization request with any body
	UpdateOrganizationWithBodyWithResponse(ctx context.Context, organizationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOrganizationResponse, error)

	UpdateOrganizationWithResponse(ctx context.Context, organizationId string, body UpdateOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOrganizationResponse, error)

	// GetClusterOptions request
	GetClusterOptionsWithResponse(ctx context.Context, organizationId string, params *GetClusterOptionsParams, reqEditors ...RequestEditorFn) (*GetClusterOptionsResponse, error)

	// ListClusters request
	ListClustersWithResponse(ctx context.Context, organizationId string, params *ListClustersParams, reqEditors ...RequestEditorFn) (*ListClustersResponse, error)

	// CreateCluster request with any body
	CreateClusterWithBodyWithResponse(ctx context.Context, organizationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error)

	CreateClusterWithResponse(ctx context.Context, organizationId string, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error)

	// DeleteCluster request
	DeleteClusterWithResponse(ctx context.Context, organizationId string, clusterId string, reqEditors ...RequestEditorFn) (*DeleteClusterResponse, error)

	// GetCluster request
	GetClusterWithResponse(ctx context.Context, organizationId string, clusterId string, reqEditors ...RequestEditorFn) (*GetClusterResponse, error)

	// UpdateCluster request with any body
	UpdateClusterWithBodyWithResponse(ctx context.Context, organizationId string, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error)

	UpdateClusterWithResponse(ctx context.Context, organizationId string, clusterId string, body UpdateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error)

	// GetDeploymentOptions request
	GetDeploymentOptionsWithResponse(ctx context.Context, organizationId string, params *GetDeploymentOptionsParams, reqEditors ...RequestEditorFn) (*GetDeploymentOptionsResponse, error)

	// ListDeployments request
	ListDeploymentsWithResponse(ctx context.Context, organizationId string, params *ListDeploymentsParams, reqEditors ...RequestEditorFn) (*ListDeploymentsResponse, error)

	// CreateDeployment request with any body
	CreateDeploymentWithBodyWithResponse(ctx context.Context, organizationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDeploymentResponse, error)

	CreateDeploymentWithResponse(ctx context.Context, organizationId string, body CreateDeploymentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDeploymentResponse, error)

	// DeleteDeployment request
	DeleteDeploymentWithResponse(ctx context.Context, organizationId string, deploymentId string, reqEditors ...RequestEditorFn) (*DeleteDeploymentResponse, error)

	// GetDeployment request
	GetDeploymentWithResponse(ctx context.Context, organizationId string, deploymentId string, reqEditors ...RequestEditorFn) (*GetDeploymentResponse, error)

	// UpdateDeployment request with any body
	UpdateDeploymentWithBodyWithResponse(ctx context.Context, organizationId string, deploymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDeploymentResponse, error)

	UpdateDeploymentWithResponse(ctx context.Context, organizationId string, deploymentId string, body UpdateDeploymentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDeploymentResponse, error)

	// ListWorkspaces request
	ListWorkspacesWithResponse(ctx context.Context, organizationId string, params *ListWorkspacesParams, reqEditors ...RequestEditorFn) (*ListWorkspacesResponse, error)

	// CreateWorkspace request with any body
	CreateWorkspaceWithBodyWithResponse(ctx context.Context, organizationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWorkspaceResponse, error)

	CreateWorkspaceWithResponse(ctx context.Context, organizationId string, body CreateWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWorkspaceResponse, error)

	// DeleteWorkspace request
	DeleteWorkspaceWithResponse(ctx context.Context, organizationId string, workspaceId string, reqEditors ...RequestEditorFn) (*DeleteWorkspaceResponse, error)

	// GetWorkspace request
	GetWorkspaceWithResponse(ctx context.Context, organizationId string, workspaceId string, reqEditors ...RequestEditorFn) (*GetWorkspaceResponse, error)

	// UpdateWorkspace request with any body
	UpdateWorkspaceWithBodyWithResponse(ctx context.Context, organizationId string, workspaceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWorkspaceResponse, error)

	UpdateWorkspaceWithResponse(ctx context.Context, organizationId string, workspaceId string, body UpdateWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWorkspaceResponse, error)
}

type ListOrganizationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrganizationsPaginated
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ListOrganizationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListOrganizationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Organization
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Organization
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClusterOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ClusterOptions
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetClusterOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClusterOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClustersPaginated
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ListClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Cluster
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON412      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r CreateClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Cluster
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Cluster
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON412      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDeploymentOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeploymentOptions
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetDeploymentOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDeploymentOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDeploymentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeploymentsPaginated
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ListDeploymentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDeploymentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDeploymentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Deployment
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r CreateDeploymentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDeploymentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDeploymentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteDeploymentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDeploymentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDeploymentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Deployment
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetDeploymentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDeploymentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDeploymentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Deployment
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateDeploymentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDeploymentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWorkspacesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkspacesPaginated
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ListWorkspacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWorkspacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateWorkspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Workspace
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r CreateWorkspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateWorkspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWorkspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteWorkspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWorkspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWorkspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Workspace
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetWorkspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWorkspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateWorkspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Workspace
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateWorkspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateWorkspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListOrganizationsWithResponse request returning *ListOrganizationsResponse
func (c *ClientWithResponses) ListOrganizationsWithResponse(ctx context.Context, params *ListOrganizationsParams, reqEditors ...RequestEditorFn) (*ListOrganizationsResponse, error) {
	rsp, err := c.ListOrganizations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListOrganizationsResponse(rsp)
}

// GetOrganizationWithResponse request returning *GetOrganizationResponse
func (c *ClientWithResponses) GetOrganizationWithResponse(ctx context.Context, organizationId string, params *GetOrganizationParams, reqEditors ...RequestEditorFn) (*GetOrganizationResponse, error) {
	rsp, err := c.GetOrganization(ctx, organizationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrganizationResponse(rsp)
}

// UpdateOrganizationWithBodyWithResponse request with arbitrary body returning *UpdateOrganizationResponse
func (c *ClientWithResponses) UpdateOrganizationWithBodyWithResponse(ctx context.Context, organizationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOrganizationResponse, error) {
	rsp, err := c.UpdateOrganizationWithBody(ctx, organizationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOrganizationResponse(rsp)
}

func (c *ClientWithResponses) UpdateOrganizationWithResponse(ctx context.Context, organizationId string, body UpdateOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOrganizationResponse, error) {
	rsp, err := c.UpdateOrganization(ctx, organizationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOrganizationResponse(rsp)
}

// GetClusterOptionsWithResponse request returning *GetClusterOptionsResponse
func (c *ClientWithResponses) GetClusterOptionsWithResponse(ctx context.Context, organizationId string, params *GetClusterOptionsParams, reqEditors ...RequestEditorFn) (*GetClusterOptionsResponse, error) {
	rsp, err := c.GetClusterOptions(ctx, organizationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClusterOptionsResponse(rsp)
}

// ListClustersWithResponse request returning *ListClustersResponse
func (c *ClientWithResponses) ListClustersWithResponse(ctx context.Context, organizationId string, params *ListClustersParams, reqEditors ...RequestEditorFn) (*ListClustersResponse, error) {
	rsp, err := c.ListClusters(ctx, organizationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListClustersResponse(rsp)
}

// CreateClusterWithBodyWithResponse request with arbitrary body returning *CreateClusterResponse
func (c *ClientWithResponses) CreateClusterWithBodyWithResponse(ctx context.Context, organizationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error) {
	rsp, err := c.CreateClusterWithBody(ctx, organizationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClusterResponse(rsp)
}

func (c *ClientWithResponses) CreateClusterWithResponse(ctx context.Context, organizationId string, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error) {
	rsp, err := c.CreateCluster(ctx, organizationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClusterResponse(rsp)
}

// DeleteClusterWithResponse request returning *DeleteClusterResponse
func (c *ClientWithResponses) DeleteClusterWithResponse(ctx context.Context, organizationId string, clusterId string, reqEditors ...RequestEditorFn) (*DeleteClusterResponse, error) {
	rsp, err := c.DeleteCluster(ctx, organizationId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteClusterResponse(rsp)
}

// GetClusterWithResponse request returning *GetClusterResponse
func (c *ClientWithResponses) GetClusterWithResponse(ctx context.Context, organizationId string, clusterId string, reqEditors ...RequestEditorFn) (*GetClusterResponse, error) {
	rsp, err := c.GetCluster(ctx, organizationId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClusterResponse(rsp)
}

// UpdateClusterWithBodyWithResponse request with arbitrary body returning *UpdateClusterResponse
func (c *ClientWithResponses) UpdateClusterWithBodyWithResponse(ctx context.Context, organizationId string, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error) {
	rsp, err := c.UpdateClusterWithBody(ctx, organizationId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClusterResponse(rsp)
}

func (c *ClientWithResponses) UpdateClusterWithResponse(ctx context.Context, organizationId string, clusterId string, body UpdateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error) {
	rsp, err := c.UpdateCluster(ctx, organizationId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClusterResponse(rsp)
}

// GetDeploymentOptionsWithResponse request returning *GetDeploymentOptionsResponse
func (c *ClientWithResponses) GetDeploymentOptionsWithResponse(ctx context.Context, organizationId string, params *GetDeploymentOptionsParams, reqEditors ...RequestEditorFn) (*GetDeploymentOptionsResponse, error) {
	rsp, err := c.GetDeploymentOptions(ctx, organizationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDeploymentOptionsResponse(rsp)
}

// ListDeploymentsWithResponse request returning *ListDeploymentsResponse
func (c *ClientWithResponses) ListDeploymentsWithResponse(ctx context.Context, organizationId string, params *ListDeploymentsParams, reqEditors ...RequestEditorFn) (*ListDeploymentsResponse, error) {
	rsp, err := c.ListDeployments(ctx, organizationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDeploymentsResponse(rsp)
}

// CreateDeploymentWithBodyWithResponse request with arbitrary body returning *CreateDeploymentResponse
func (c *ClientWithResponses) CreateDeploymentWithBodyWithResponse(ctx context.Context, organizationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDeploymentResponse, error) {
	rsp, err := c.CreateDeploymentWithBody(ctx, organizationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDeploymentResponse(rsp)
}

func (c *ClientWithResponses) CreateDeploymentWithResponse(ctx context.Context, organizationId string, body CreateDeploymentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDeploymentResponse, error) {
	rsp, err := c.CreateDeployment(ctx, organizationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDeploymentResponse(rsp)
}

// DeleteDeploymentWithResponse request returning *DeleteDeploymentResponse
func (c *ClientWithResponses) DeleteDeploymentWithResponse(ctx context.Context, organizationId string, deploymentId string, reqEditors ...RequestEditorFn) (*DeleteDeploymentResponse, error) {
	rsp, err := c.DeleteDeployment(ctx, organizationId, deploymentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDeploymentResponse(rsp)
}

// GetDeploymentWithResponse request returning *GetDeploymentResponse
func (c *ClientWithResponses) GetDeploymentWithResponse(ctx context.Context, organizationId string, deploymentId string, reqEditors ...RequestEditorFn) (*GetDeploymentResponse, error) {
	rsp, err := c.GetDeployment(ctx, organizationId, deploymentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDeploymentResponse(rsp)
}

// UpdateDeploymentWithBodyWithResponse request with arbitrary body returning *UpdateDeploymentResponse
func (c *ClientWithResponses) UpdateDeploymentWithBodyWithResponse(ctx context.Context, organizationId string, deploymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDeploymentResponse, error) {
	rsp, err := c.UpdateDeploymentWithBody(ctx, organizationId, deploymentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDeploymentResponse(rsp)
}

func (c *ClientWithResponses) UpdateDeploymentWithResponse(ctx context.Context, organizationId string, deploymentId string, body UpdateDeploymentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDeploymentResponse, error) {
	rsp, err := c.UpdateDeployment(ctx, organizationId, deploymentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDeploymentResponse(rsp)
}

// ListWorkspacesWithResponse request returning *ListWorkspacesResponse
func (c *ClientWithResponses) ListWorkspacesWithResponse(ctx context.Context, organizationId string, params *ListWorkspacesParams, reqEditors ...RequestEditorFn) (*ListWorkspacesResponse, error) {
	rsp, err := c.ListWorkspaces(ctx, organizationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWorkspacesResponse(rsp)
}

// CreateWorkspaceWithBodyWithResponse request with arbitrary body returning *CreateWorkspaceResponse
func (c *ClientWithResponses) CreateWorkspaceWithBodyWithResponse(ctx context.Context, organizationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWorkspaceResponse, error) {
	rsp, err := c.CreateWorkspaceWithBody(ctx, organizationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWorkspaceResponse(rsp)
}

func (c *ClientWithResponses) CreateWorkspaceWithResponse(ctx context.Context, organizationId string, body CreateWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWorkspaceResponse, error) {
	rsp, err := c.CreateWorkspace(ctx, organizationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWorkspaceResponse(rsp)
}

// DeleteWorkspaceWithResponse request returning *DeleteWorkspaceResponse
func (c *ClientWithResponses) DeleteWorkspaceWithResponse(ctx context.Context, organizationId string, workspaceId string, reqEditors ...RequestEditorFn) (*DeleteWorkspaceResponse, error) {
	rsp, err := c.DeleteWorkspace(ctx, organizationId, workspaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWorkspaceResponse(rsp)
}

// GetWorkspaceWithResponse request returning *GetWorkspaceResponse
func (c *ClientWithResponses) GetWorkspaceWithResponse(ctx context.Context, organizationId string, workspaceId string, reqEditors ...RequestEditorFn) (*GetWorkspaceResponse, error) {
	rsp, err := c.GetWorkspace(ctx, organizationId, workspaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWorkspaceResponse(rsp)
}

// UpdateWorkspaceWithBodyWithResponse request with arbitrary body returning *UpdateWorkspaceResponse
func (c *ClientWithResponses) UpdateWorkspaceWithBodyWithResponse(ctx context.Context, organizationId string, workspaceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWorkspaceResponse, error) {
	rsp, err := c.UpdateWorkspaceWithBody(ctx, organizationId, workspaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWorkspaceResponse(rsp)
}

func (c *ClientWithResponses) UpdateWorkspaceWithResponse(ctx context.Context, organizationId string, workspaceId string, body UpdateWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWorkspaceResponse, error) {
	rsp, err := c.UpdateWorkspace(ctx, organizationId, workspaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWorkspaceResponse(rsp)
}

// ParseListOrganizationsResponse parses an HTTP response from a ListOrganizationsWithResponse call
func ParseListOrganizationsResponse(rsp *http.Response) (*ListOrganizationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListOrganizationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrganizationsPaginated
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOrganizationResponse parses an HTTP response from a GetOrganizationWithResponse call
func ParseGetOrganizationResponse(rsp *http.Response) (*GetOrganizationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Organization
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateOrganizationResponse parses an HTTP response from a UpdateOrganizationWithResponse call
func ParseUpdateOrganizationResponse(rsp *http.Response) (*UpdateOrganizationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Organization
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetClusterOptionsResponse parses an HTTP response from a GetClusterOptionsWithResponse call
func ParseGetClusterOptionsResponse(rsp *http.Response) (*GetClusterOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClusterOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ClusterOptions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListClustersResponse parses an HTTP response from a ListClustersWithResponse call
func ParseListClustersResponse(rsp *http.Response) (*ListClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClustersPaginated
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateClusterResponse parses an HTTP response from a CreateClusterWithResponse call
func ParseCreateClusterResponse(rsp *http.Response) (*CreateClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Cluster
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteClusterResponse parses an HTTP response from a DeleteClusterWithResponse call
func ParseDeleteClusterResponse(rsp *http.Response) (*DeleteClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetClusterResponse parses an HTTP response from a GetClusterWithResponse call
func ParseGetClusterResponse(rsp *http.Response) (*GetClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Cluster
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateClusterResponse parses an HTTP response from a UpdateClusterWithResponse call
func ParseUpdateClusterResponse(rsp *http.Response) (*UpdateClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Cluster
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDeploymentOptionsResponse parses an HTTP response from a GetDeploymentOptionsWithResponse call
func ParseGetDeploymentOptionsResponse(rsp *http.Response) (*GetDeploymentOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDeploymentOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeploymentOptions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListDeploymentsResponse parses an HTTP response from a ListDeploymentsWithResponse call
func ParseListDeploymentsResponse(rsp *http.Response) (*ListDeploymentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDeploymentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeploymentsPaginated
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateDeploymentResponse parses an HTTP response from a CreateDeploymentWithResponse call
func ParseCreateDeploymentResponse(rsp *http.Response) (*CreateDeploymentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDeploymentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Deployment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteDeploymentResponse parses an HTTP response from a DeleteDeploymentWithResponse call
func ParseDeleteDeploymentResponse(rsp *http.Response) (*DeleteDeploymentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDeploymentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDeploymentResponse parses an HTTP response from a GetDeploymentWithResponse call
func ParseGetDeploymentResponse(rsp *http.Response) (*GetDeploymentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDeploymentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Deployment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateDeploymentResponse parses an HTTP response from a UpdateDeploymentWithResponse call
func ParseUpdateDeploymentResponse(rsp *http.Response) (*UpdateDeploymentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDeploymentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Deployment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListWorkspacesResponse parses an HTTP response from a ListWorkspacesWithResponse call
func ParseListWorkspacesResponse(rsp *http.Response) (*ListWorkspacesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWorkspacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkspacesPaginated
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateWorkspaceResponse parses an HTTP response from a CreateWorkspaceWithResponse call
func ParseCreateWorkspaceResponse(rsp *http.Response) (*CreateWorkspaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateWorkspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Workspace
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteWorkspaceResponse parses an HTTP response from a DeleteWorkspaceWithResponse call
func ParseDeleteWorkspaceResponse(rsp *http.Response) (*DeleteWorkspaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWorkspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetWorkspaceResponse parses an HTTP response from a GetWorkspaceWithResponse call
func ParseGetWorkspaceResponse(rsp *http.Response) (*GetWorkspaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWorkspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Workspace
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateWorkspaceResponse parses an HTTP response from a UpdateWorkspaceWithResponse call
func ParseUpdateWorkspaceResponse(rsp *http.Response) (*UpdateWorkspaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateWorkspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Workspace
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}
