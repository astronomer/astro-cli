// Code generated by mockery v2.9.4. DO NOT EDIT.

package mocks

import (
	context "context"

	auth "github.com/containers/common/pkg/auth"
	containers "github.com/containers/podman/v3/pkg/bindings/containers"

	entities "github.com/containers/podman/v3/pkg/domain/entities"

	handlers "github.com/containers/podman/v3/pkg/api/handlers"

	images "github.com/containers/podman/v3/pkg/bindings/images"

	mock "github.com/stretchr/testify/mock"

	play "github.com/containers/podman/v3/pkg/bindings/play"

	pods "github.com/containers/podman/v3/pkg/bindings/pods"

	types "github.com/containers/image/v5/types"
)

// PodmanBind is an autogenerated mock type for the PodmanBind type
type PodmanBind struct {
	mock.Mock
}

// Build provides a mock function with given fields: ctx, containerFiles, options
func (_m *PodmanBind) Build(ctx context.Context, containerFiles []string, options entities.BuildOptions) (*entities.BuildReport, error) {
	ret := _m.Called(ctx, containerFiles, options)

	var r0 *entities.BuildReport
	if rf, ok := ret.Get(0).(func(context.Context, []string, entities.BuildOptions) *entities.BuildReport); ok {
		r0 = rf(ctx, containerFiles, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entities.BuildReport)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, []string, entities.BuildOptions) error); ok {
		r1 = rf(ctx, containerFiles, options)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExecCreate provides a mock function with given fields: ctx, nameOrID, config
func (_m *PodmanBind) ExecCreate(ctx context.Context, nameOrID string, config *handlers.ExecCreateConfig) (string, error) {
	ret := _m.Called(ctx, nameOrID, config)

	var r0 string
	if rf, ok := ret.Get(0).(func(context.Context, string, *handlers.ExecCreateConfig) string); ok {
		r0 = rf(ctx, nameOrID, config)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, *handlers.ExecCreateConfig) error); ok {
		r1 = rf(ctx, nameOrID, config)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExecStartAndAttach provides a mock function with given fields: ctx, sessionID, options
func (_m *PodmanBind) ExecStartAndAttach(ctx context.Context, sessionID string, options *containers.ExecStartAndAttachOptions) error {
	ret := _m.Called(ctx, sessionID, options)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *containers.ExecStartAndAttachOptions) error); ok {
		r0 = rf(ctx, sessionID, options)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Exists provides a mock function with given fields: ctx, nameOrID, options
func (_m *PodmanBind) Exists(ctx context.Context, nameOrID string, options *pods.ExistsOptions) (bool, error) {
	ret := _m.Called(ctx, nameOrID, options)

	var r0 bool
	if rf, ok := ret.Get(0).(func(context.Context, string, *pods.ExistsOptions) bool); ok {
		r0 = rf(ctx, nameOrID, options)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, *pods.ExistsOptions) error); ok {
		r1 = rf(ctx, nameOrID, options)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetImage provides a mock function with given fields: ctx, nameOrID, options
func (_m *PodmanBind) GetImage(ctx context.Context, nameOrID string, options *images.GetOptions) (*entities.ImageInspectReport, error) {
	ret := _m.Called(ctx, nameOrID, options)

	var r0 *entities.ImageInspectReport
	if rf, ok := ret.Get(0).(func(context.Context, string, *images.GetOptions) *entities.ImageInspectReport); ok {
		r0 = rf(ctx, nameOrID, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entities.ImageInspectReport)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, *images.GetOptions) error); ok {
		r1 = rf(ctx, nameOrID, options)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Kube provides a mock function with given fields: ctx, path, options
func (_m *PodmanBind) Kube(ctx context.Context, path string, options *play.KubeOptions) (*entities.PlayKubeReport, error) {
	ret := _m.Called(ctx, path, options)

	var r0 *entities.PlayKubeReport
	if rf, ok := ret.Get(0).(func(context.Context, string, *play.KubeOptions) *entities.PlayKubeReport); ok {
		r0 = rf(ctx, path, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entities.PlayKubeReport)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, *play.KubeOptions) error); ok {
		r1 = rf(ctx, path, options)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// List provides a mock function with given fields: ctx, options
func (_m *PodmanBind) List(ctx context.Context, options *containers.ListOptions) ([]entities.ListContainer, error) {
	ret := _m.Called(ctx, options)

	var r0 []entities.ListContainer
	if rf, ok := ret.Get(0).(func(context.Context, *containers.ListOptions) []entities.ListContainer); ok {
		r0 = rf(ctx, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]entities.ListContainer)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *containers.ListOptions) error); ok {
		r1 = rf(ctx, options)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Login provides a mock function with given fields: ctx, systemContext, opts, args
func (_m *PodmanBind) Login(ctx context.Context, systemContext *types.SystemContext, opts *auth.LoginOptions, args []string) error {
	ret := _m.Called(ctx, systemContext, opts, args)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.SystemContext, *auth.LoginOptions, []string) error); ok {
		r0 = rf(ctx, systemContext, opts, args)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Logs provides a mock function with given fields: ctx, nameOrID, options, stdoutChan, stderrChan
func (_m *PodmanBind) Logs(ctx context.Context, nameOrID string, options *containers.LogOptions, stdoutChan chan string, stderrChan chan string) error {
	ret := _m.Called(ctx, nameOrID, options, stdoutChan, stderrChan)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *containers.LogOptions, chan string, chan string) error); ok {
		r0 = rf(ctx, nameOrID, options, stdoutChan, stderrChan)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewConnection provides a mock function with given fields: ctx, uri
func (_m *PodmanBind) NewConnection(ctx context.Context, uri string) (context.Context, error) {
	ret := _m.Called(ctx, uri)

	var r0 context.Context
	if rf, ok := ret.Get(0).(func(context.Context, string) context.Context); ok {
		r0 = rf(ctx, uri)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(context.Context)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, uri)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Push provides a mock function with given fields: ctx, source, destination, options
func (_m *PodmanBind) Push(ctx context.Context, source string, destination string, options *images.PushOptions) error {
	ret := _m.Called(ctx, source, destination, options)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *images.PushOptions) error); ok {
		r0 = rf(ctx, source, destination, options)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Remove provides a mock function with given fields: ctx, nameOrID, options
func (_m *PodmanBind) Remove(ctx context.Context, nameOrID string, options *pods.RemoveOptions) (*entities.PodRmReport, error) {
	ret := _m.Called(ctx, nameOrID, options)

	var r0 *entities.PodRmReport
	if rf, ok := ret.Get(0).(func(context.Context, string, *pods.RemoveOptions) *entities.PodRmReport); ok {
		r0 = rf(ctx, nameOrID, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entities.PodRmReport)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, *pods.RemoveOptions) error); ok {
		r1 = rf(ctx, nameOrID, options)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Start provides a mock function with given fields: ctx, nameOrID, options
func (_m *PodmanBind) Start(ctx context.Context, nameOrID string, options *pods.StartOptions) (*entities.PodStartReport, error) {
	ret := _m.Called(ctx, nameOrID, options)

	var r0 *entities.PodStartReport
	if rf, ok := ret.Get(0).(func(context.Context, string, *pods.StartOptions) *entities.PodStartReport); ok {
		r0 = rf(ctx, nameOrID, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entities.PodStartReport)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, *pods.StartOptions) error); ok {
		r1 = rf(ctx, nameOrID, options)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Stop provides a mock function with given fields: ctx, nameOrID, options
func (_m *PodmanBind) Stop(ctx context.Context, nameOrID string, options *pods.StopOptions) (*entities.PodStopReport, error) {
	ret := _m.Called(ctx, nameOrID, options)

	var r0 *entities.PodStopReport
	if rf, ok := ret.Get(0).(func(context.Context, string, *pods.StopOptions) *entities.PodStopReport); ok {
		r0 = rf(ctx, nameOrID, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entities.PodStopReport)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, *pods.StopOptions) error); ok {
		r1 = rf(ctx, nameOrID, options)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Tag provides a mock function with given fields: ctx, nameOrID, tag, repo, options
func (_m *PodmanBind) Tag(ctx context.Context, nameOrID string, tag string, repo string, options *images.TagOptions) error {
	ret := _m.Called(ctx, nameOrID, tag, repo, options)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, *images.TagOptions) error); ok {
		r0 = rf(ctx, nameOrID, tag, repo, options)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Untag provides a mock function with given fields: ctx, nameOrID, tag, repo, options
func (_m *PodmanBind) Untag(ctx context.Context, nameOrID string, tag string, repo string, options *images.UntagOptions) error {
	ret := _m.Called(ctx, nameOrID, tag, repo, options)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, *images.UntagOptions) error); ok {
		r0 = rf(ctx, nameOrID, tag, repo, options)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}
